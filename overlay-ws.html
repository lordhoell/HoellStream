<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HoellStream - Stream Events</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    html, body {
      height: 100%; margin: 0; padding: 0;
      background: #000; color: #B266FF;
      font-family: 'Press Start 2P', sans-serif;
      font-size: clamp(8px, 1.2vw, 16px);
      display: flex; flex-direction: column; overflow: hidden;
      min-width: 600px; min-height: 400px;
    }
    .stats-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1em 0;
      background: rgba(0,0,0,0.95);
      border-bottom: 3px solid #8000FF;
      box-shadow: inset 0 0 0 14px #000, 0 0 12px #000C;
    }
    .platform-row {
      display: grid;
      grid-template-columns: 3.5vw repeat(5, 15vw);
      column-gap: 2vw;
      margin-bottom: 0.5em;
      justify-content: center;
      white-space: nowrap;
    }
    /* Platform icon container with status indicator */
    .platform-icon-container {
      position: relative;
      width: 3.5vw; 
      height: 4.7vw;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-top: 0.0vw;
      background: #8000FF;
      border-radius: 6px;
      border: 2px solid #8000FF;
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
      z-index: 1;
    }
    
    .platform-icon-inline {
      width: 2.5vw; 
      height: 2.5vw;
      filter: none;
      z-index: 2;
    }
    
    /* Connection status indicator - now changes the box background */
    .connection-status {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 6px;
      z-index: 1;
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
    }
    .status-indicator {
      display: inline-block;
      width: 1vw;
      height: 1vw;
      border-radius: 50%;
      margin-right: 0.5vw;
    }
    .status-connected {
      background-color: rgba(46, 204, 113, 0.8) !important;
      border: 1px solid #2ecc71 !important;
    }
    .status-disconnected {
      background-color: rgba(231, 76, 60, 0.8) !important;
      border: 1px solid #e74c3c !important;
    }
    .status-scheduled {
      background-color: rgba(243, 156, 18, 0.8) !important;
      border: 1px solid #f39c12 !important;
    }
    /* Hover effects for clickable platform icons */
    .platform-icon-container.clickable:hover {
      transform: scale(1.05);
      filter: brightness(1.2);
      cursor: pointer;
    }
    
    .platform-icon-container.clickable:active {
      transform: scale(0.95);
    }
    
    .stat {
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      width: 15vw; height: 4vw;
      padding: 0.4em;
      border: 2px solid #8000FF; border-radius: 6px;
      background: rgba(128,0,255,0.1);
      box-shadow: inset 0 0 4px #000;
      text-align: center;
    }
    .stat label { color: #B266FF; font-size: clamp(6px, 0.9vw, 14px); margin-bottom: 0.2em; white-space: nowrap; }
    .stat span  { color: #FFF; font-weight: bold; font-size: clamp(8px, 1.4vw, 18px); }
    
    /* First stat box in each row connects to platform icon */
    .platform-row .stat:first-of-type {
      border-radius: 6px;
      border: 2px solid #8000FF;
      padding: 0.4em;
      position: relative;
      z-index: 1;
    }
    
    .stat.polling { padding: 0.4em; }
    .stat.polling button {
      width: 100%; font-family: 'Press Start 2P'; font-size: 0.75em;
      color: #B266FF; background: transparent;
      border: 1px solid #B266FF; border-radius: 4px;
      padding: 0.3em; margin: 0.1em 0; cursor: pointer;
      white-space: nowrap;
    }
    .feed-header {
      position: sticky; top: 0;
      background: rgba(0,0,0,0.95);
      padding: 0.5em; border-bottom: 1px solid #8000FF;
      text-align: center; font-size: clamp(10px, 1.25vw, 20px); font-weight: bold;
      z-index: 10;
    }
    .feed {
      flex:1; overflow-y:auto;
      padding: 0 0 0 3.5vw; width: 87vw; margin:0 auto;
    }
    /* Make scrollbar invisible but functional */
    .feed::-webkit-scrollbar {
      width: 12px;
    }
    .feed::-webkit-scrollbar-track {
      background: transparent;
    }
    .feed::-webkit-scrollbar-thumb {
      background: transparent;
    }
    .feed::-webkit-scrollbar-thumb:hover {
      background: transparent;
    }
    
    /* Firefox scrollbar styling */
    .feed {
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* Internet Explorer 10+ */
    }
    .item {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.5em;
      border: 1px solid #8000FF;
      border-radius: 0 4px 4px 0;
      width: 100%;
      min-width: 0;
      min-height: 4vw;
      background: #000;
      margin: 0;
      box-sizing: border-box;
    }
    .item .left-content {
      display: flex;
      align-items: center;
      flex: 1;
      min-width: 0;
    }
    .item .right-content {
      display: flex;
      align-items: center;
      margin-left: auto;
      white-space: nowrap;
    }
    .avatar { width:3vw; height:3vw; border-radius:50%; margin-right:0.5em; }
    .username { flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; margin-right:0.5em; }
    .details { text-align:right; font-size:0.9em; white-space:nowrap; }
/* make TikTok gift pics slightly wider and better centered in the event boxes */
.details img.icon, .gift-icon, .details img, img.gift-icon, .item img, #feed img {
  width: 2.5vw !important;
  height: 2.5vw !important;
  margin-right: 0.5em;
  max-width: 2.5vw !important;
  max-height: 2.5vw !important;
  object-fit: contain !important;
  vertical-align: middle !important;
  display: inline-block !important;
}

/* Catch any remaining images in the overlay */
#overlay img, .overlay img {
  max-width: 2.5vw !important;
  max-height: 2.5vw !important;
  width: auto !important;
  height: auto !important;
  vertical-align: middle !important;
}
    /* Clickable YouTube icon styles */
    .platform-icon-container.clickable {
      cursor: pointer;
      transition: transform 0.1s ease, filter 0.2s ease;
      user-select: none;
    }
    
    /* Loading animation for YouTube icon */
    @keyframes youtubeLoading {
      0% { transform: rotate(0deg) scale(1); }
      50% { transform: rotate(180deg) scale(1.1); }
      100% { transform: rotate(360deg) scale(1); }
    }
    
    .platform-icon-container.loading .platform-icon-inline {
      animation: youtubeLoading 1s ease-in-out infinite;
    }
    
    .platform-icon-container.loading .connection-status {
      background-color: rgba(255, 165, 0, 0.4);
      box-shadow: 0 0 12px rgba(255, 165, 0, 0.6);
    }
    
    /* Loading animation for Twitch icon */
    @keyframes twitchLoading {
      0% { transform: rotate(0deg) scale(1); }
      50% { transform: rotate(180deg) scale(1.1); }
      100% { transform: rotate(360deg) scale(1); }
    }
    
    .platform-icon-container.twitch-loading .platform-icon-inline {
      animation: twitchLoading 1s ease-in-out infinite;
    }
    
    .platform-icon-container.twitch-loading .connection-status {
      background-color: rgba(147, 83, 255, 0.4);
      box-shadow: 0 0 12px rgba(147, 83, 255, 0.6);
    }
    
    /* Enhanced status transitions */
    .connection-status {
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
    }

    /* full-screen white flash */
    #bladeFlashOverlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: white;
      opacity: 0;
      pointer-events: none;
      z-index: 9999;
    }

    /* three quick scale-pulses */
    @keyframes pulseScale {
      0%, 100% { transform: scale(1); }
      50%      { transform: scale(1.05); }
    }

    /* single white "blade pull" flash */
    @keyframes bladeFlashAnim {
      0%   { opacity: 1; }
      20%  { opacity: 0.6; }
      100% { opacity: 0; }
    }

    .flashPulse {
      /* position:relative so the pseudo-flash is confined here */
      position: relative;
      animation: pulseScale 0.333s ease-in-out 0s 3 both;
    }

    /* use a pseudo-element to flash just this item */
    .flashPulse::before {
      content: "";
      position: absolute;
      inset: 0;
      background: white;
      pointer-events: none;
      opacity: 0;
      animation: bladeFlashAnim 1s ease-in-out 0s 1 both;
    }

    .item.tiktok-item { background: rgba(127,0,255,0.15); }
    .tiktok-gift-counting { color: #FF2222 !important; font-weight: bold; text-shadow: 0 0 6px #FF2222, 0 0 2px #fff; }

    /* Shake and light-up animation for stream events */
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); }
      20%, 40%, 60%, 80% { transform: translateX(8px); }
    }
    @keyframes boxLight {
      0% { box-shadow: 0 0 24px 8px #fff, 0 0 0 #8000FF; }
      100% { box-shadow: 0 0 0 #8000FF; }
    }
    .item.event-animate {
      animation: flashPulse 1s cubic-bezier(.36,.07,.19,.97) both;
      z-index: 2;
    }
    @keyframes flashPulse {
      0% { box-shadow: 0 0 24px 8px #fff, 0 0 0 #8000FF; }
      40% { box-shadow: 0 0 32px 16px #FFD700, 0 0 0 #8000FF; }
      80% { box-shadow: 0 0 12px 4px #8000FF, 0 0 0 #FFD700; }
      100% { box-shadow: 0 0 0 #8000FF; }
    }

    /* Ensure animations don't affect structure */
    .event-animate {
      position: relative;
      z-index: 2;
    }

    .item.twitch-item, .item.youtube-item, .item.tiktok-item { background: #000; } /* All events pure black */

    /* Provider icon box styling */
    .event-row {
      display: flex;
      align-items: stretch;
      width: 100%;
      max-width: 100%;
      margin: 0.5em 0;
      box-sizing: border-box;
      position: relative;
      z-index: 1;
    }
    .provider-icon-box {
      display: flex;
      align-items: center;
      justify-content: center;
      background: #8000FF;
      border-radius: 6px 0 0 6px;
      width: 3.5vw;
      min-width: 3.5vw;
      height: auto;
      z-index: 3; /* Ensure it's above animations */
      position: relative; /* Needed for z-index to work */
    }
    .provider-icon-box img {
      width: 2.5vw;
      height: 2.5vw;
      filter: none;
    }

    .avatar { width:3vw; height:3vw; border-radius:50%; margin-right:0.5em; }
    .gift-membership {
      min-height: 4vw;
    }
    .superchat {
      min-height: 4vw;
    }
    .supersticker {
      min-height: 4vw;
    }
  </style>
</head>
<body>
  <div class="stats-wrapper">
    <div class="platform-row">
      <div class="platform-icon-container">
        <div class="connection-status status-disconnected" id="tiktok-status"></div>
        <img class="platform-icon-inline" src="https://www.tiktok.com/favicon.ico" alt="TikTok" />
      </div>
      <div class="stat"><label>Viewers:</label><span id="tiktokViewers">0</span></div>
      <div class="stat"><label>Follows:</label><span id="tiktokFollows">0</span></div>
      <div class="stat"><label>Subs:</label><span id="tiktokSubs">0</span></div>
      <div class="stat"><label>Diamonds:</label><span id="tiktokDiamonds">0</span></div>
      <div class="stat"><label>Likes:</label><span id="tiktokLikes">0</span></div>
    </div>
    <div class="platform-row">
      <div class="platform-icon-container clickable twitch-icon">
        <div class="connection-status status-disconnected" id="twitch-status"></div>
        <img class="platform-icon-inline" src="https://www.twitch.tv/favicon.ico" alt="Twitch" />
      </div>
      <div class="stat"><label>Viewers:</label><span id="twitchViewers">–</span></div>
      <div class="stat"><label>Follows:</label><span id="twitchFollows">0</span></div>
      <div class="stat"><label>Subs:</label><span id="twitchSubs">0</span></div>
      <div class="stat"><label>Bits:</label><span id="twitchBits">0</span></div>
      <div class="stat"><label>Raids:</label><span id="twitchRaids">0</span></div>
    </div>
    <div class="platform-row">
      <div class="platform-icon-container clickable youtube-icon">
        <div class="connection-status status-disconnected" id="youtube-status"></div>
        <img class="platform-icon-inline" src="https://www.youtube.com/favicon.ico" alt="YouTube" />
      </div>
      <div class="stat"><label>Viewers:</label><span id="ytViewers">–</span></div>
      <div class="stat"><label>Subscribers:</label><span id="ytSubscribers">0</span></div>
      <div class="stat"><label>Members:</label><span id="ytMembers">0</span></div>
      <div class="stat"><label>SuperChats:</label><span id="ytSuperchats">0</span></div>
      <div class="stat polling">
        <button id="ytPollBtn" style="display: none;">Start YouTube</button>
        <button id="ytStopBtn" style="display: none;">Stop YouTube</button>
      </div>
    </div>
  </div>
  <div class="feed-header">Stream Events</div>
  <div class="feed"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script>
(async () => {
  // Load both config and OAuth tokens
  const CONFIG = await window.electron.ipcRenderer.invoke('load-config');
  let TOKENS = await window.electron.ipcRenderer.invoke('get-tokens');
  
  // Apply font sizes from config
  if (CONFIG) {
    // Apply overlay event box size
    if (CONFIG.OVERLAY_FONT_SIZE) {
      const style = document.createElement('style');
      style.setAttribute('data-dynamic-font', 'true');
      style.textContent = `
        .item { 
          min-height: calc(44px * ${CONFIG.OVERLAY_FONT_SIZE}) !important;
          padding: calc(0.5em * ${CONFIG.OVERLAY_FONT_SIZE}) !important;
        }
        .item .left-content {
          font-size: calc(1em * ${CONFIG.OVERLAY_FONT_SIZE}) !important;
        }
        .item .right-content {
          font-size: calc(1em * ${CONFIG.OVERLAY_FONT_SIZE}) !important;
        }
      `;
      document.head.appendChild(style);
    }
    
    // Apply stats font size
    if (CONFIG.STATS_FONT_SIZE) {
      const style = document.createElement('style');
      style.setAttribute('data-dynamic-font', 'true');
      style.textContent = `.stat span { font-size: ${CONFIG.STATS_FONT_SIZE}em !important; }`;
      document.head.appendChild(style);
    }
  }

  // Initialization flag to prevent operations during startup
  let isInitialized = false;

  // YouTube service state tracking
  let youtubeServiceRunning = false;
  let youtubeServiceLoading = false;

  // Twitch service state tracking
  let twitchServiceRunning = false;
  let twitchServiceLoading = false;

  // Get YouTube icon container for click handling
  const youtubeIconContainer = document.querySelector('.platform-icon-container.clickable.youtube-icon');
  const youtubeStatusElement = document.getElementById('youtube-status');

  // Get Twitch icon container for click handling
  const twitchIconContainer = document.querySelector('.platform-icon-container.clickable.twitch-icon');
  const twitchStatusElement = document.getElementById('twitch-status');

  // YouTube icon click handler
  youtubeIconContainer.addEventListener('click', async () => {
    if (!isInitialized) {
      console.log('[Overlay] System still initializing, please wait...');
      return;
    }
    
    if (youtubeServiceLoading) {
      console.log('[Overlay] YouTube service operation in progress, ignoring click');
      return;
    }

    console.log(`[Overlay] YouTube icon clicked - Current state: ${youtubeServiceRunning ? 'running' : 'stopped'}`);
    
    if (youtubeServiceRunning) {
      // Stop YouTube service
      await stopYouTubeService();
    } else {
      // Start YouTube service
      await startYouTubeService();
    }
  });

  // Twitch icon click handler
  twitchIconContainer.addEventListener('click', async () => {
    if (!isInitialized) {
      console.log('[Overlay] System still initializing, please wait...');
      return;
    }
    
    if (twitchServiceLoading) {
      console.log('[Overlay] Twitch service operation in progress, ignoring click');
      return;
    }

    if (twitchServiceRunning) {
      await stopTwitchService();
    } else {
      await startTwitchService();
    }
  });

  // Start YouTube service function
  async function startYouTubeService() {
    console.log('[Overlay] Starting YouTube service...');
    setYouTubeLoading(true);
    
    try {
      const result = await window.electron.ipcRenderer.invoke('youtube-service-start');
      
      if (result && result.success) {
        console.log('✅ [Overlay] YouTube service started successfully');
        youtubeServiceRunning = true;
        updateConnectionStatus('youtube', true);
      } else {
        console.error('❌ [Overlay] Failed to start YouTube service:', result?.error || 'Unknown error');
        youtubeServiceRunning = false;
        updateConnectionStatus('youtube', false);
      }
    } catch (error) {
      console.error('❌ [Overlay] Error starting YouTube service:', error);
      youtubeServiceRunning = false;
      updateConnectionStatus('youtube', false);
    } finally {
      setYouTubeLoading(false);
    }
  }

  // Stop YouTube service function
  async function stopYouTubeService() {
    console.log('[Overlay] Stopping YouTube service...');
    setYouTubeLoading(true);
    
    try {
      await window.electron.ipcRenderer.invoke('youtube-service-stop');
      console.log('✅ [Overlay] YouTube service stopped successfully');
      youtubeServiceRunning = false;
      updateConnectionStatus('youtube', false);
    } catch (error) {
      console.error('❌ [Overlay] Error stopping YouTube service:', error);
      // Still mark as stopped even if there was an error
      youtubeServiceRunning = false;
      updateConnectionStatus('youtube', false);
    } finally {
      setYouTubeLoading(false);
    }
  }

  // Start Twitch service function
  async function startTwitchService() {
    console.log('[Overlay] Starting Twitch service...');
    setTwitchLoading(true);
    
    try {
      const result = await window.electron.ipcRenderer.invoke('twitch-service-start');
      
      if (result && result.success) {
        console.log('✅ [Overlay] Twitch service started successfully');
        twitchServiceRunning = true;
        updateConnectionStatus('twitch', true);
      } else {
        console.log('⚠️ [Overlay] Twitch service start - no explicit success response, waiting for status update');
        // Don't set to connected here - let the connection status listener handle it
      }
    } catch (error) {
      console.error('❌ [Overlay] Error starting Twitch service:', error);
      twitchServiceRunning = false;
      updateConnectionStatus('twitch', false);
    } finally {
      setTwitchLoading(false);
    }
  }

  // Stop Twitch service function
  async function stopTwitchService() {
    console.log('[Overlay] Stopping Twitch service...');
    setTwitchLoading(true);
    
    try {
      await window.electron.ipcRenderer.invoke('twitch-service-stop');
      console.log('✅ [Overlay] Twitch service stopped successfully');
      twitchServiceRunning = false;
      updateConnectionStatus('twitch', false);
    } catch (error) {
      console.error('❌ [Overlay] Error stopping Twitch service:', error);
      // Still mark as stopped even if there was an error
      twitchServiceRunning = false;
      updateConnectionStatus('twitch', false);
    } finally {
      setTwitchLoading(false);
    }
  }

  // Set loading state for YouTube icon
  function setYouTubeLoading(loading) {
    youtubeServiceLoading = loading;
    if (loading) {
      youtubeIconContainer.classList.add('loading');
    } else {
      youtubeIconContainer.classList.remove('loading');
    }
  }

  // Set loading state for Twitch icon
  function setTwitchLoading(loading) {
    twitchServiceLoading = loading;
    if (loading) {
      twitchIconContainer.classList.add('twitch-loading');
    } else {
      twitchIconContainer.classList.remove('twitch-loading');
    }
  }

  // Update existing button handlers to sync with icon state
  document.getElementById('ytPollBtn').addEventListener('click', async () => {
    if (youtubeServiceLoading || youtubeServiceRunning) return;
    await startYouTubeService();
  });

  document.getElementById('ytStopBtn').addEventListener('click', async () => {
    if (youtubeServiceLoading || !youtubeServiceRunning) return;
    await stopYouTubeService();
  });

  // Only log that overlay is loaded without exposing sensitive config values
  
  // Set up YouTube polling button handlers
  $('#ytPollBtn').on('click', async function() {
    sessionStorage.setItem('youtubePollingEnabled', 'true');
    $(this).prop('disabled', true);
    $('#ytStopBtn').prop('disabled', false);

    // Start the YouTube service via IPC
    try {
      await window.electron.ipcRenderer.invoke('youtube-service-start');
      updateConnectionStatus('youtube', true);
    } catch (error) {
      console.error('Failed to start YouTube service:', error);
      updateConnectionStatus('youtube', false);
    }
  });
  
  $('#ytStopBtn').on('click', async function() {
    sessionStorage.setItem('youtubePollingEnabled', 'false');
    $(this).prop('disabled', true);
    $('#ytPollBtn').prop('disabled', false);
    $('#ytViewers').text('–');
    updateConnectionStatus('youtube', false);
    
    // Stop the YouTube service via IPC
    try {
      await window.electron.ipcRenderer.invoke('youtube-service-stop');
    } catch (error) {
      console.error('Failed to stop YouTube service:', error);
    }
  });

  // Stats fetch
  let ytStatsInterval;

  document.getElementById('ytPollBtn').addEventListener('click', () => {
    if (ytStatsInterval) return;  // only start once
    // ytStatsInterval replaced with individual polling for Twitch and YouTube if needed.
    // Example: setInterval(fetchYouTubeStats, 60000); // Uncomment if polling is required
    updateConnectionStatus('youtube', true);
  });
  
  document.getElementById('ytStopBtn').addEventListener('click', () => {
    if (!ytStatsInterval) return;
    clearInterval(ytStatsInterval);
    ytStatsInterval = null;
    updateConnectionStatus('youtube', false);
  });

  
  // Set up the interval for regular updates (every 60 seconds)
  // Don't automatically call polling on page load - wait for button click
  // setInterval(fetchTwitchStatus, 60000); // Uncomment if periodic polling needed
// setInterval(fetchYouTubeStats, 60000); // Uncomment if periodic polling needed

  // Function to ensure we have a valid Twitch token
  async function ensureTwitchToken() {
    if (!TOKENS.twitch || !TOKENS.twitch.access_token) {
      console.error('No Twitch token available');
      return false;
    }

    try {
      const refreshed = await window.electron.ipcRenderer.invoke('refresh-tokens', 'twitch');
      
      if (refreshed) {
        // Get the updated tokens
        TOKENS = await window.electron.ipcRenderer.invoke('get-tokens');
        return true;
      } else {
        console.error('Failed to refresh Twitch token');
        updateConnectionStatus('twitch', false);
        return false;
      }
    } catch (error) {
      console.error('Error refreshing Twitch token:', error);
      updateConnectionStatus('twitch', false);
      return false;
    }

    // Validate the token and get client ID
    try {
      const validateResponse = await fetch('https://id.twitch.tv/oauth2/validate', {
        headers: { 'Authorization': `OAuth ${TOKENS.twitch.access_token}` }
      });
      
      if (!validateResponse.ok) {
        console.error('Twitch token validation failed:', validateResponse.status);
        
        // Try to get more detailed error information
        try {
          const errorText = await validateResponse.text();
          console.error('▶ [DEBUG] Error response:', errorText);
        } catch (e) {
          console.error('▶ [DEBUG] Could not read error response:', e);
        }
        
        // Try to refresh the token
        try {
          const refreshed = await window.electron.ipcRenderer.invoke('refresh-tokens', 'twitch');
          if (refreshed) {
            TOKENS = await window.electron.ipcRenderer.invoke('get-tokens');
            } else {
            console.error('▶ [DEBUG] Token refresh failed. User may need to re-authenticate with Twitch');
          }
        } catch (refreshError) {
          console.error('▶ [DEBUG] Error during token refresh:', refreshError);
        }
        return false;
      }
      
      const validateData = await validateResponse.json();
      if (!validateData.scopes.includes('channel:read:subscriptions')) {
        console.error('Missing Twitch token scopes: channel:read:subscriptions');
        console.error('Available scopes:', validateData.scopes.join(', '));
        console.error('Please re-authenticate with the correct scopes');
      }

      return true;
    } catch (error) {
      console.error('Error validating Twitch token:', error);
      updateConnectionStatus('twitch', false);
      return false;
    }
  }

  // Function to get Twitch channel info for the authenticated user
  async function getTwitchChannelInfo() {
    try {
      // Make sure we have a token
      if (!TOKENS.twitch || !TOKENS.twitch.access_token) {
        console.error('No Twitch token available for channel info');
        return null;
      }
      
      // Validate the token to get the user login and ID
      const validateResponse = await fetch('https://id.twitch.tv/oauth2/validate', {
        headers: {
          'Authorization': `OAuth ${TOKENS.twitch.access_token}`
        }
      });
      
      if (!validateResponse.ok) {
        console.error(`Token validation failed: ${validateResponse.status}`);
        
        // Try to get more detailed error information
        try {
          const errorText = await validateResponse.text();
          console.error('▶ [DEBUG] Error response:', errorText);
        } catch (e) {
          console.error('▶ [DEBUG] Could not read error response:', e);
        }
        
        // Try to refresh the token
        try {
          const refreshed = await window.electron.ipcRenderer.invoke('refresh-tokens', 'twitch');
          if (refreshed) {
            TOKENS = await window.electron.ipcRenderer.invoke('get-tokens');
          } else {
            console.error('▶ [DEBUG] Token refresh failed. User may need to re-authenticate with Twitch');
          }
        } catch (refreshError) {
          console.error('▶ [DEBUG] Error during token refresh:', refreshError);
        }
        return null;
      }
      
      const validateData = await validateResponse.json();
      // Store channel ID if we don't have it yet
      if (!twitchChannelId) {
        twitchChannelId = validateData.user_id;
        twitchChannelName = validateData.login.toLowerCase();
        }
      
      // Return the user info directly from the validation response
      return {
        id: validateData.user_id,
        login: validateData.login,
        display_name: validateData.login
      };
      
      const data = await response.json();
      
      if (!data.data || !data.data.length) {
        console.error('No valid Twitch channel info available in response');
        return null;
      }
      
      const userInfo = data.data[0];
      return {
        id: userInfo.id,
        login: userInfo.login,
        display_name: userInfo.display_name,
        profile_image_url: userInfo.profile_image_url,
        broadcaster_type: userInfo.broadcaster_type
      };
    } catch (error) {
      console.error('Error in getTwitchChannelInfo:', error);
      return null;
    }
  }

  // Function to get Twitch stream info
  async function getTwitchStreamInfo() {
    try {
      // Make sure we have a token
      if (!TOKENS.twitch || !TOKENS.twitch.access_token) {
        return { success: false, error: 'No Twitch token available' };
      }
      
      // First get the user info to get the channel ID
      const channelInfo = await getTwitchChannelInfo();
      if (!channelInfo || !channelInfo.id) {
        return { success: false, error: 'Could not get channel ID' };
      }
      
      // Return success with channel info, even if we can't check live status
      return {
        success: true,
        live: false,  // Default to not live
        channelId: channelInfo.id,
        channelName: channelInfo.login
      };
    } catch (error) {
      console.error('Error in getTwitchStreamInfo:', error);
      return { success: false, error: error.message };
    }
  }

  // Enhanced polling for Twitch events
  let lastFollowersCheck = 0;
  let lastSubscribersCheck = 0;
  let lastBitsCheck = 0;
  
  // Twitch event counters
  let tF = 0, tS = 0, tB = 0, tR = 0;
  
  // Timestamps for last API checks
  // We're using the tracking sets defined earlier in the code
  
  // Function to set up enhanced Twitch polling and direct chat monitoring
  async function setupEnhancedTwitchPolling(channel) {
    try {
      // Validate channel
      if (!channel) {
        console.error('▶ No channel specified for Twitch polling');
        return false;
      }
      
      // Initialize the polling system
      // Clear any existing polling intervals
      if (window.twitchEventsInterval) {
        clearInterval(window.twitchEventsInterval);
      }
      
      // Set up polling intervals for different event types
      // Poll every 10 seconds for new followers, subscribers, bits, and channel point redemptions
      window.twitchEventsInterval = setInterval(async () => {
        if (!twitchConnected) return;
        
        try {
          // Check for new followers
          await checkNewFollowers();
          
          // Check for new subscribers
          await checkNewSubscribers();
          
          // Check for gift subscriptions
          await checkGiftSubscriptions();
          
          // Check for new bits/cheers via Helix API
          await checkNewBits();
          
          // Check for new channel point redemptions
          await checkChannelPointRedemptions();
        } catch (error) {
          console.error('Error in Twitch polling:', error);
        }
      }, 10000);
      
      // Set up direct Twitch chat WebSocket connection for real-time events
      connectToTwitchChat();
      
      return true;
    } catch (error) {
      console.error('Error setting up Twitch polling:', error);
      return false;
    }
  }
  
  // Variables for Twitch chat WebSocket
  let twitchChatReconnectTimeout = null;
  
  // Function to parse IRC messages from Twitch chat
  function parseIrcMessage(rawMessage) {
    try {
      // Handle PING messages to keep the connection alive
      if (rawMessage.startsWith('PING')) {
        twitchChatSocket.send('PONG :tmi.twitch.tv');
        return;
      }
      
      // Skip empty messages
      if (!rawMessage || rawMessage.trim() === '') {
        return;
      }
      
      // Parse the message
      const messageParts = rawMessage.split(' ');
      
      // Extract tags if present
      let tags = {};
      if (messageParts[0].startsWith('@')) {
        const tagPart = messageParts[0].substring(1);
        const tagPairs = tagPart.split(';');
        
        for (const pair of tagPairs) {
          const [key, value] = pair.split('=');
          tags[key] = value;
        }
        
        // Remove the tags part from the message
        messageParts.shift();
      }
      
      // Handle different message types
      if (messageParts.indexOf('PRIVMSG') > -1) {
        // Chat message
        const channelIndex = messageParts.indexOf('PRIVMSG');
        const channel = messageParts[channelIndex + 1].substring(1);
        
        // Extract username
        const usernamePart = messageParts[0];
        const username = usernamePart.substring(1, usernamePart.indexOf('!'));
        
        // Extract message content
        const messageContent = messageParts.slice(channelIndex + 2).join(' ').substring(1);
        
        // Check for bits in the message
        if (tags.bits) {
          // Handle bits event using the standard Twitch event handler
          handleTwitchEvent('bits', {
            username: username,
            displayName: tags['display-name'] || username,
            id: tags.id,
            userId: tags['user-id'],
            avatar: tags['user-id'] ? `https://static-cdn.jtvnw.net/jtv_user_pictures/${tags['user-id']}-profile_image-300x300.png` : '',
            bits: parseInt(tags.bits),
            amount: parseInt(tags.bits),
            message: messageContent
          });
        }
        
        // Check for channel point redemptions in the custom-reward-id tag
        // This is a special case where channel point redemptions appear in chat messages
        if (tags['custom-reward-id']) {
          // Create a unique ID for this redemption
          const redemptionId = `${tags['custom-reward-id']}-${tags.id}`;
          
          // Skip if we've already processed this redemption
          if (knownRedemptions.has(redemptionId)) return;
          knownRedemptions.add(redemptionId);
          
          // Get reward name if possible or use a default
          const rewardTitle = tags['msg-param-reward-title'] || tags['custom-reward-title'] || 'Channel Point Reward';
          
          // Update redemption counter
          tR++; $('#twitchRedemptions').text(tR);
          
          // Add item to the feed
          addItem({
            avatar: tags['user-id'] ? `https://static-cdn.jtvnw.net/jtv_user_pictures/${tags['user-id']}-profile_image-300x300.png` : '',
            name: tags['display-name'] || username,
            html: `Redeemed <span class="highlight">${rewardTitle}</span>: ${messageContent}`,
            provider: 'twitch'
          });
          
          // Log the event for debugging
          }
      } else if (messageParts.indexOf('USERNOTICE') > -1) {
        // Subscription, raid, or other special events
        const channelIndex = messageParts.indexOf('USERNOTICE');
        const channel = messageParts[channelIndex + 1].substring(1);
        
        // Extract message content if any
        let messageContent = '';
        if (messageParts.length > channelIndex + 2) {
          messageContent = messageParts.slice(channelIndex + 2).join(' ').substring(1);
        }
        
        // Handle different types of user notices
        const msgId = tags['msg-id'];
        
        if (msgId === 'sub' || msgId === 'resub') {
          // Subscription or resubscription
          // Update subscription counter
          tS++; $('#twitchSubs').text(tS);
          
          // Get avatar URL
          const avatarUrl = tags['user-id'] ? 
            `https://static-cdn.jtvnw.net/jtv_user_pictures/${tags['user-id']}-profile_image-300x300.png` : 
            '';
          
          // Use handleTwitchEvent to process the subscription
          handleTwitchEvent('subscription', {
            username: tags.login,
            displayName: tags['display-name'],
            avatar: avatarUrl,
            months: parseInt(tags['msg-param-cumulative-months'] || '1'),
            message: messageContent,
            isGift: false,
            tier: tags['msg-param-sub-plan'] || '1000'
          });
          
          // Log the event
          } else if (msgId === 'subgift' || msgId === 'anonsubgift') {
          // Gift subscription
          // Update subscription counter
          tS++; $('#twitchSubs').text(tS);
          
          // Get gifter and recipient names
          const gifter = tags['display-name'] || 'Anonymous';
          const recipient = tags['msg-param-recipient-display-name'] || tags['msg-param-recipient-user-name'] || 'Someone';
          
          // Get avatar URL for the gifter - use a more reliable format
          let avatarUrl = '';
          if (tags['user-id']) {
            // First try the more reliable format
            avatarUrl = `https://static-cdn.jtvnw.net/user-profile-pictures/${tags['user-id']}-profile_image-300x300.png`;
            } else {
            // Use Twitch favicon as fallback
            avatarUrl = 'https://static.twitchcdn.net/assets/favicon-32-e29e246c157142c94346.png';
            }
          
          // Use handleTwitchEvent to process the gift subscription
          handleTwitchEvent('subscription', {
            username: tags['msg-param-recipient-user-name'],
            displayName: recipient,
            avatar: avatarUrl,
            gifter: gifter,
            gifterDisplayName: gifter,
            isGift: true,
            message: messageContent,
            tier: tags['msg-param-sub-plan'] || '1000'
          });
          
          // DIRECT FEED UPDATE - Ensure the gift sub appears in the feed
          try {
            // Add directly to the feed as a backup method
            const $feed = $('.feed');
            const $item = $(`<div class="event-row">
              <div class='provider-icon-box'><img src='https://static.twitchcdn.net/assets/favicon-32-e29e246c157142c94346.png' alt='twitch'></div>
              <div class="item twitch-item">
                <img class="avatar" src="${avatarUrl}" alt="">
                <div class="username">${gifter}</div>
                <div class="details">GIFT SUB to ${recipient}</div>
              </div>
            </div>`);
            $feed.append($item);
            $feed.each(function() { this.scrollTop = this.scrollHeight; });
            
            // Limit to 30 most recent events
            while ($feed.children('.event-row').length > 30) {
              $feed.children('.event-row').first().remove();
            }
          } catch (error) {
            console.error('▶ Error adding gift sub directly to feed:', error);
          }
          
          // Log the event
          } else if (msgId === 'raid') {
          // Raid event
          // Handle raid event
          handleTwitchEvent('raid', {
            username: tags.login,
            displayName: tags['display-name'],
            avatar: '',
            viewers: parseInt(tags['msg-param-viewerCount'] || '0')
          });
        }
      }
    } catch (error) {
      console.error('Error parsing IRC message:', error, rawMessage);
    }
  }
  
  // Function to check for new followers
  async function checkNewFollowers() {
    try {
      if (!twitchConnected || !twitchChannelId || !TOKENS?.twitch?.access_token) return;
      
      // Only check if it's been at least 10 seconds since the last check
      const now = Date.now();
      if (now - lastFollowersCheck < 10000) return;
      lastFollowersCheck = now;
      
      // Get the client ID from the validated token if possible
      const clientId = TOKENS.twitch.client_id || validatedClientId;
      
      // Get the latest followers using the recent followers endpoint
      const followersResponse = await fetch(`https://api.twitch.tv/helix/channels/followers/recent?broadcaster_id=${twitchChannelId}&first=10`, {
        headers: {
          'Client-ID': clientId,
          'Authorization': `Bearer ${TOKENS.twitch.access_token}`
        }
      });
      
      if (!followersResponse.ok) {
        console.error(`▶ Failed to fetch followers: ${followersResponse.status}`);
        
        // Try to get more detailed error information
        try {
          const errorText = await followersResponse.text();
          console.error('▶ [DEBUG] Error response:', errorText);
        } catch (e) {
          console.error('▶ [DEBUG] Could not read error response:', e);
        }
        
        return;
      }
      
      const followersData = await followersResponse.json();
      // Initialize knownFollowers if this is the first run
      if (knownFollowers.size === 0) {
        // First run - just store all known followers without triggering events
        if (followersData.data && followersData.data.length > 0) {
          for (const follower of followersData.data) {
            knownFollowers.add(follower.user_id);
          }
        }
        return;
      }
      
      // Process new followers (only on subsequent checks)
      if (followersData.data && followersData.data.length > 0) {
        // Only process followers from the last 5 minutes to avoid old follows appearing as new
        const fiveMinutesAgo = now - (5 * 60 * 1000);
        
        // Sort followers by followed_at date to process oldest first
        // This ensures we don't trigger multiple events out of order
        const sortedFollowers = [...followersData.data].sort((a, b) => {
          return new Date(a.followed_at).getTime() - new Date(b.followed_at).getTime();
        });
        
        for (const follower of sortedFollowers) {
          const followerId = follower.user_id;
          const followedAt = new Date(follower.followed_at).getTime();
          
          // Check if this is a new follower we haven't seen before AND it's recent
          if (!knownFollowers.has(followerId) && followedAt > fiveMinutesAgo) {
            // Add to known followers BEFORE processing to prevent duplicates
            knownFollowers.add(followerId);
            
            // Handle the follower event
            // Update follower counter
            tF++; $('#twitchFollows').text(tF);
            
            // Add to event feed
            addItem({
              avatar: `https://static-cdn.jtvnw.net/jtv_user_pictures/${followerId}-profile_image-300x300.png`,
              name: follower.user_login,
              html: 'FOLLOWED',
              provider: 'twitch'
            });
            
            // Log the event
            } else if (!knownFollowers.has(followerId)) {
            // Add to known followers without triggering an event if it's old
            knownFollowers.add(followerId);
          }
        }
      }
    } catch (error) {
      console.error('Error checking for new followers:', error);
    }
  }
  
  // Function to check for new subscribers
  async function checkNewSubscribers() {
    try {
      if (!twitchConnected || !twitchChannelId) {
        return;
      }
      
      // Only check if it's been at least 10 seconds since the last check
      const now = Date.now();
      if (!window.lastSubscribersCheck) window.lastSubscribersCheck = 0;
      if (now - window.lastSubscribersCheck < 10000) {
        return;
      }
      window.lastSubscribersCheck = now;
      
      // First, validate that we have the required scope
      try {
        const validateResponse = await fetch('https://id.twitch.tv/oauth2/validate', {
          headers: { 'Authorization': `OAuth ${TOKENS.twitch.access_token}` }
        });
        
        if (!validateResponse.ok) {
          console.error(`▶ [DEBUG] Token validation failed: ${validateResponse.status}`);
          
          // Try to get more detailed error information
          try {
            const errorText = await validateResponse.text();
            console.error('▶ [DEBUG] Token validation error response:', errorText);
          } catch (e) {
            console.error('▶ [DEBUG] Could not read token validation error response:', e);
          }
          
          // Try to refresh the token
          try {
            const refreshed = await window.electron.ipcRenderer.invoke('refresh-tokens', 'twitch');
            if (refreshed) {
              TOKENS = await window.electron.ipcRenderer.invoke('get-tokens');
              } else {
              console.error('▶ [DEBUG] Token refresh failed. User may need to re-authenticate with Twitch');
            }
          } catch (refreshError) {
            console.error('▶ [DEBUG] Error during token refresh:', refreshError);
          }
          return;
        }
        
        const validateData = await validateResponse.json();
        if (!validateData.scopes.includes('channel:read:subscriptions')) {
          console.error('▶ [DEBUG] Missing required scope: channel:read:subscriptions');
          console.error('▶ [DEBUG] Available scopes:', validateData.scopes.join(', '));
          console.error('▶ [DEBUG] Please re-authenticate with the correct scopes');
          return;
        }
        
        // Client ID is already hardcoded, no need to set it from validation
        
      } catch (error) {
        console.error('▶ [DEBUG] Error validating token:', error);
        return;
      }
      
      // Get the latest subscribers
      // Increased from 10 to 100 to avoid missing subscribers
      try {
        const subsResponse = await fetch(`https://api.twitch.tv/helix/subscriptions?broadcaster_id=${twitchChannelId}&first=100`, {
          headers: {
            'Client-ID': validatedClientId,
            'Authorization': `Bearer ${TOKENS.twitch.access_token}`
          }
        });
        
        if (!subsResponse.ok) {
          console.error(`▶ [DEBUG] Failed to fetch subscribers: ${subsResponse.status} ${subsResponse.statusText}`);
          
          // Try to get more detailed error information
          try {
            const errorText = await subsResponse.text();
            console.error('▶ [DEBUG] Error response body:', errorText);
          } catch (e) {
            console.error('▶ [DEBUG] Could not read error response body:', e);
          }
          
          if (subsResponse.status === 401 || subsResponse.status === 403) {
            console.error('▶ [DEBUG] Missing required scope: channel:read:subscriptions. Please re-authenticate with this scope.');
          }
          return;
        }
        
        const subsData = await subsResponse.json();
        // Debug: Log sample subscription data
        if (subsData.data && subsData.data.length > 0) {
          // Log a few more samples if available
          if (subsData.data.length > 1) {
            }
        } else {
          }
        
        // Process new subscribers (excluding gift subs which are handled separately)
        if (subsData.data && subsData.data.length > 0) {
          // Filter out gift subscriptions which are handled by checkGiftSubscriptions
          const directSubs = subsData.data.filter(sub => sub.is_gift !== true);
          // Log gift vs non-gift counts
          const giftSubs = subsData.data.filter(sub => sub.is_gift === true);
          // Get the current timestamp
          const currentTime = Date.now();
          
          // Initialize knownSubscribers if not already done
          if (!window.knownSubscribers) {
            window.knownSubscribers = new Set();
            }
          
          // Debug: Log some known subscribers if any exist
          if (window.knownSubscribers.size > 0) {
            }
          
          for (const sub of directSubs) {
            // Create a unique ID for this subscription that doesn't include time
            // This helps prevent duplicate events across sessions
            const subId = `${sub.user_id}-${sub.tier}`;
            
            // Check if this is a new subscriber we haven't seen before
            if (!window.knownSubscribers.has(subId)) {
              window.knownSubscribers.add(subId);
              // Update subscription counter
              tS++; $('#twitchSubs').text(tS);
              // Add to event feed
              addItem({
                avatar: sub.user_id ? `https://static-cdn.jtvnw.net/jtv_user_pictures/${sub.user_id}-profile_image-300x300.png` : '',
                name: sub.user_name,
                html: `SUBSCRIBED (Tier ${sub.tier.replace('1000', '1').replace('2000', '2').replace('3000', '3')})`,
                provider: 'twitch'
              });
              
              // Log the event
              } else {
              }
          }
        }
      } catch (error) {
        console.error('Error checking for new subscribers:', error);
      }
    } catch (error) {
      console.error('Error checking for new subscribers:', error);
    }
  }
  
  // Function to check for gift subscriptions
  async function checkGiftSubscriptions() {
    try {
      if (!twitchConnected || !twitchChannelId) {
        return;
      }
      
      // Only check if it's been at least 10 seconds since the last check
      const now = Date.now();
      // Using a separate timestamp for gift subs
      if (!window.lastGiftSubsCheck) window.lastGiftSubsCheck = 0;
      if (now - window.lastGiftSubsCheck < 10000) {
        return;
      }
      window.lastGiftSubsCheck = now;
      
      // First, validate that we have the required scope
      try {
        const validateResponse = await fetch('https://id.twitch.tv/oauth2/validate', {
          headers: { 'Authorization': `OAuth ${TOKENS.twitch.access_token}` }
        });
        
        if (!validateResponse.ok) {
          console.error(`▶ [DEBUG-GIFT] Token validation failed: ${validateResponse.status}`);
          
          // Try to get more detailed error information
          try {
            const errorText = await validateResponse.text();
            console.error('▶ [DEBUG-GIFT] Token validation error response:', errorText);
          } catch (e) {
            console.error('▶ [DEBUG-GIFT] Could not read token validation error response:', e);
          }
          
          // Try to refresh the token
          try {
            const refreshed = await window.electron.ipcRenderer.invoke('refresh-tokens', 'twitch');
            if (refreshed) {
              TOKENS = await window.electron.ipcRenderer.invoke('get-tokens');
              } else {
              console.error('▶ [DEBUG-GIFT] Token refresh failed. User may need to re-authenticate with Twitch');
            }
          } catch (refreshError) {
            console.error('▶ [DEBUG-GIFT] Error during token refresh:', refreshError);
          }
          return;
        }
        
        const validateData = await validateResponse.json();
        if (!validateData.scopes.includes('channel:read:subscriptions')) {
          console.error('▶ [DEBUG-GIFT] Missing required scope: channel:read:subscriptions');
          console.error('▶ [DEBUG-GIFT] Available scopes:', validateData.scopes.join(', '));
          console.error('▶ [DEBUG-GIFT] Please re-authenticate with the correct scopes');
          return;
        }
        
        // Client ID is already hardcoded, no need to set it from validation
        
      } catch (error) {
        console.error('▶ [DEBUG-GIFT] Error validating token:', error);
        return;
      }
      
      // Get recent gift subscriptions using the subscriptions endpoint
      try {
        const subsResponse = await fetch(`https://api.twitch.tv/helix/subscriptions?broadcaster_id=${twitchChannelId}&first=100`, {
          headers: {
            'Client-ID': validatedClientId,
            'Authorization': `Bearer ${TOKENS.twitch.access_token}`
          }
        });
        
        if (!subsResponse.ok) {
          console.error(`▶ [DEBUG-GIFT] Failed to fetch gift subscriptions: ${subsResponse.status} ${subsResponse.statusText}`);
          
          // Try to get more detailed error information
          try {
            const errorText = await subsResponse.text();
            console.error('▶ [DEBUG-GIFT] Error response body:', errorText);
          } catch (e) {
            console.error('▶ [DEBUG-GIFT] Could not read error response body:', e);
          }
          
          if (subsResponse.status === 401 || subsResponse.status === 403) {
            console.error('▶ [DEBUG-GIFT] Missing required scope: channel:read:subscriptions. Please re-authenticate with this scope.');
          }
          return;
        }
        
        const subsData = await subsResponse.json();
        // Debug: Log all subscription data to see what we're getting
        if (subsData.data && subsData.data.length > 0) {
          // Log a few more samples if available
          if (subsData.data.length > 1) {
            }
        } else {
          }
        
        // Process gift subscriptions
        if (subsData.data && subsData.data.length > 0) {
          // Filter for gift subscriptions only
          const giftSubs = subsData.data.filter(sub => sub.is_gift === true);
          // Debug: Log gift subscription details
          if (giftSubs.length > 0) {
            } else {
            }
          
          // Get the current timestamp
          const currentTime = Date.now();
          
          // Initialize knownGiftSubs if not already done
          if (!window.knownGiftSubs) {
            window.knownGiftSubs = new Set();
            }
          
          // Debug: Log some known gift subs if any exist
          if (window.knownGiftSubs.size > 0) {
            }
          
          for (const sub of giftSubs) {
            // Create a unique ID for this gift subscription
            // Include recipient ID, gifter ID, and tier to make it unique
            // DO NOT include time in the ID to avoid duplicates across sessions
            const giftSubId = `gift-${sub.user_id}-${sub.gifter_id || 'anonymous'}-${sub.tier}`;
            
            // Check if this is a new gift subscription we haven't seen before
            if (!window.knownGiftSubs.has(giftSubId)) {
              const gifterName = sub.gifter_name || 'Anonymous';
              const recipientName = sub.user_name;
              
              window.knownGiftSubs.add(giftSubId);
              // Update subscription counter
              tS++; $('#twitchSubs').text(tS);
              // Add to event feed
              addItem({
                avatar: sub.gifter_id ? `https://static-cdn.jtvnw.net/jtv_user_pictures/${sub.gifter_id}-profile_image-300x300.png` : '',
                name: gifterName,
                html: `GIFT SUB to ${recipientName} (Tier ${sub.tier.replace('1000', '1').replace('2000', '2').replace('3000', '3')})`,
                provider: 'twitch'
              });
              
              // Log the event
              } else {
              }
          }
        }
      } catch (error) {
        console.error('▶ [DEBUG-GIFT] Error in gift subscription API call:', error);
      }
    } catch (error) {
      console.error('Error checking for gift subscriptions:', error);
    }
  }
  
  // Function to check for new bits/cheers
  async function checkNewBits() {
    try {
      if (!twitchConnected || !twitchChannelId) return;
      
      // Only check if it's been at least 10 seconds since the last check
      const now = Date.now();
      if (now - lastBitsCheck < 10000) return;
      lastBitsCheck = now;
      
      // Get bits leaderboard to check for recent cheers
      // Note: This API doesn't provide individual cheer events directly
      // but we can use it to detect new cheers by comparing with previous state
      const bitsResponse = await fetch(`https://api.twitch.tv/helix/bits/leaderboard?count=10`, {
        headers: {
          'Client-ID': validatedClientId,
          'Authorization': `Bearer ${TOKENS.twitch.access_token}`
        }
      });
      
      if (!bitsResponse.ok) {
        // This might fail if the user doesn't have the right scopes
        if (bitsResponse.status === 401) {
          // Try to refresh the token
          const refreshed = await window.electron.ipcRenderer.invoke('refresh-tokens', 'twitch');
          
          if (refreshed) {
            // Get the updated tokens
            TOKENS = await window.electron.ipcRenderer.invoke('get-tokens');
          }
        }
        return;
      }
      
      const bitsData = await bitsResponse.json();
      // Initialize bits tracking if not already done
      if (!window.previousBitsAmounts) {
        window.previousBitsAmounts = new Map();
      }
      
      // Process bits leaderboard entries
      if (bitsData.data && bitsData.data.length > 0) {
        for (const entry of bitsData.data) {
          const userId = entry.user_id;
          const userName = entry.user_name;
          const currentScore = entry.score; // Total bits cheered
          
          // Check if we've seen this user before
          const previousScore = window.previousBitsAmounts.get(userId) || 0;
          
          // If the current score is higher than the previous score, a new cheer happened
          if (currentScore > previousScore) {
            const bitsAmount = currentScore - previousScore;
            
            // Create a unique ID for this bits event
            const bitsId = `${userId}_${bitsAmount}_${now}`;
            
            // Check if this is a new bits event we haven't seen before
            if (!knownCheerers.has(bitsId)) {
              knownCheerers.add(bitsId);
              
              // Update bits counter
              tB += bitsAmount; $('#twitchBits').text(tB);
              
              // Add to event feed
              addItem({
                avatar: userId ? `https://static-cdn.jtvnw.net/jtv_user_pictures/${userId}-profile_image-300x300.png` : '',
                name: userName,
                html: `CHEERED <span style="color:#9C3EE8">${bitsAmount} bits</span>`,
                provider: 'twitch'
              });
              
              // Log the event
              }
          }
          
          // Update the previous score for this user
          window.previousBitsAmounts.set(userId, currentScore);
        }
      }
      
      // We also rely on the chat message parsing for bits detection
      // as it provides more immediate feedback for individual cheer events
    } catch (error) {
      console.error('Error checking for new bits:', error);
    }
  }
  
  // Variable to track if channel points API is available
  let channelPointsApiAvailable = true;
  
  // Function to check for new channel point redemptions
  async function checkChannelPointRedemptions() {
    try {
      if (!twitchConnected || !twitchChannelId) return;
      
      // Skip if we've already determined the API is not available
      if (!channelPointsApiAvailable) return;
      
      // Only check if it's been at least 10 seconds since the last check
      const now = Date.now();
      if (now - lastChannelPointsCheck < 10000) return;
      lastChannelPointsCheck = now;
      
      // Get custom rewards for the channel
      const rewardsResponse = await fetch(`https://api.twitch.tv/helix/channel_points/custom_rewards?broadcaster_id=${twitchChannelId}`, {
        headers: {
          'Client-ID': validatedClientId,
          'Authorization': `Bearer ${TOKENS.twitch.access_token}`
        }
      });
      
      // Handle 403 Forbidden (missing scopes) by disabling this feature
      if (rewardsResponse.status === 403) {
        channelPointsApiAvailable = false;
        return;
      }
      
      if (!rewardsResponse.ok) {
        return;
      }
      
      const rewardsData = await rewardsResponse.json();
      
      // For each reward, check recent redemptions
      if (rewardsData.data && rewardsData.data.length > 0) {
        for (const reward of rewardsData.data) {
          // Get recent redemptions for this reward
          const redemptionsResponse = await fetch(`https://api.twitch.tv/helix/channel_points/custom_rewards/redemptions?broadcaster_id=${twitchChannelId}&reward_id=${reward.id}&status=FULFILLED&first=5`, {
            headers: {
              'Client-ID': validatedClientId,
              'Authorization': `Bearer ${TOKENS.twitch.access_token}`
            }
          });
          
          // Skip this reward if we get a 403 or other error
          if (!redemptionsResponse.ok) {
            continue;
          }
          
          const redemptionsData = await redemptionsResponse.json();
          
          // First run - just store redemption IDs without triggering events
          if (knownRedemptions.size === 0) {
            if (redemptionsData.data && redemptionsData.data.length > 0) {
              for (const redemption of redemptionsData.data) {
                knownRedemptions.add(redemption.id);
              }
            }
            continue;
          }
          
          // Process new redemptions (only on subsequent checks)
          if (redemptionsData.data && redemptionsData.data.length > 0) {
            // Only process redemptions from the last 5 minutes
            const fiveMinutesAgo = now - (5 * 60 * 1000);
            
            for (const redemption of redemptionsData.data) {
              const redemptionId = redemption.id;
              const redeemedAt = new Date(redemption.redeemed_at).getTime();
              
              // Check if this is a new redemption we haven't seen before AND it's recent
              if (!knownRedemptions.has(redemptionId) && redeemedAt > fiveMinutesAgo) {
                knownRedemptions.add(redemptionId);
                
                // Handle the redemption
                handleChannelPointRedemption(
                  redemption.user_name,
                  redemption.user_name,
                  reward.id,
                  reward.title,
                  redemption.user_input || ''
                );
              } else if (!knownRedemptions.has(redemptionId)) {
                // Add to known redemptions without triggering an event if it's old
                knownRedemptions.add(redemptionId);
              }
            }
          }
        }
      }
    } catch (error) {
      console.error('Error checking for channel point redemptions:', error);
    }
  }
  
  // Function to handle channel point redemptions
  function handleChannelPointRedemption(username, displayName, rewardId, rewardTitle, message) {
    try {
      // Create a unique ID for this redemption
      const redemptionId = `${rewardId}-${Date.now()}`;
      
      // Skip if we've already processed this event
      if (knownRedemptions.has(redemptionId)) return;
      knownRedemptions.add(redemptionId);
      
      // Handle the redemption event (using the cheer event type for now)
      handleTwitchEvent('cheer', {
        username: username,
        displayName: displayName,
        avatar: '', // We don't get avatar in chat
        bits: 0, // No bits for redemptions
        message: `Redeemed ${rewardTitle}: ${message}`
      });
    } catch (error) {
      console.error('Error handling channel point redemption:', error);
    }
  }
  
  // Helper function to handle subscription events
  function handleSubscriptionEvent(username, userstate, message, isGift = false, months = 1, gifter = null) {
    try {
      // Create a unique ID for this subscription event
      const subId = `${userstate['user-id'] || Date.now()}`;
      
      // Skip if we've already processed this event
      if (knownSubscribers.has(subId)) return;
      knownSubscribers.add(subId);
      
      // Determine tier
      let tier = '1000'; // Default to Tier 1
      if (userstate.plan === '2000') tier = '2000';
      if (userstate.plan === '3000') tier = '3000';
      
      // Handle the subscription event
      handleTwitchEvent('subscription', {
        username: username,
        displayName: userstate['display-name'] || username,
        avatar: '', // We don't get avatar in chat
        tier: tier,
        isGift: isGift,
        gifter: gifter,
        months: months,
        message: message || ''
      });
    } catch (error) {
      console.error('Error handling subscription event:', error);
    }
  }
  
  // Helper function to handle bits events
  function handleBitsEvent(userstate, message, bits) {
    try {
      // Create a unique ID for this bits event
      const bitsId = `${userstate.id || Date.now()}`;
      
      // Skip if we've already processed this event
      if (knownCheerers.has(bitsId)) return;
      knownCheerers.add(bitsId);
      
      // Handle the bits event
      handleTwitchEvent('cheer', {
        username: userstate.username,
        displayName: userstate['display-name'],
        avatar: '', // We don't get avatar in chat
        bits: bits,
        message: message
      });
    } catch (error) {
      console.error('Error handling bits event:', error);
    }
  }
  
  // Consolidated function to check all Twitch events (followers, subscriptions, bits)
  async function checkTwitchEvents() {
    // Check if we have the required data to make API calls
    // Note: We're not relying on twitchConnected flag as it might not be in sync with actual token state
    if (!TOKENS?.twitch?.access_token) {
      return;
    }
    
    try {
      // First, explicitly validate the token to ensure it's valid and get the client ID
      let validateData = null;
      let validateResponse = null;
      
      try {
        validateResponse = await fetch('https://id.twitch.tv/oauth2/validate', {
          headers: {
            'Authorization': `Bearer ${TOKENS.twitch.access_token}`
          }
        });
        
        if (!validateResponse.ok) {
          console.error(`Token validation failed: ${validateResponse.status}`);
          
          // Try to refresh the token
          const refreshed = await window.electron.ipcRenderer.invoke('refresh-tokens', 'twitch');
          
          if (refreshed) {
            // Get the updated tokens
            TOKENS = await window.electron.ipcRenderer.invoke('get-tokens');
          }
        }
        validateData = await validateResponse.json();
        
      } catch (validateError) {
        console.error('Error validating Twitch token:', validateError);
        return;
      }
      
      // Now we have a validated token, proceed with API calls
      const now = Date.now();
      
      // Create common headers for all API requests with validated client ID
      const headers = {
        'Client-ID': validatedClientId,
        'Authorization': `Bearer ${TOKENS.twitch.access_token}`
      };
      
      // Log the headers we're using
      // 1. CHECK FOR NEW FOLLOWERS
      // Only check every 10 seconds to avoid API rate limits but catch follows quickly
      if (now - lastFollowersCheck >= 10000) {
        lastFollowersCheck = now;
        try {
          const followersResponse = await fetch(
            `https://api.twitch.tv/helix/channels/followers?broadcaster_id=${twitchChannelId}&first=100`,
            { headers }
          );
          
          if (followersResponse.ok) {
            const followersData = await followersResponse.json();
            
            if (followersData.data && Array.isArray(followersData.data)) {
              // Sort followers by follow date (oldest first) to process in chronological order
              // This ensures we don't trigger multiple events out of order
              const sortedFollows = [...followersData.data].sort((a, b) => {
                return new Date(a.followed_at).getTime() - new Date(b.followed_at).getTime();
              });
              
              // Initialize knownFollowers set if it doesn't exist
              if (!window.knownFollowers) {
                window.knownFollowers = new Set();
              }
              
              // On first run, just store all followers without triggering events
              if (window.knownFollowers.size === 0) {
                for (const follow of sortedFollows) {
                  const followerKey = `follow-${follow.user_id}`;
                  window.knownFollowers.add(followerKey);
                }
              } else {
                let newFollowCount = 0;
                
                for (const follow of sortedFollows) {
                  // Create a unique follower key based on user_id
                  const followerKey = `follow-${follow.user_id}`;
                  
                  // Skip if we've already processed this follower
                  if (window.knownFollowers.has(followerKey)) continue;
                  
                  // Add to known followers set before processing to prevent duplicates
                  window.knownFollowers.add(followerKey);
                  newFollowCount++;
                  
                  // Check if the follow is recent (within the last 5 minutes)
                  const startupTime = window.startupTime || Date.now();
                  const timeSinceStartup = now - startupTime;
                  if (timeSinceStartup > 600000) {
                    continue;
                  }
                  
                  // Get user avatar using the centralized function
                  let avatar = '';
                  try {
                    const userResponse = await fetch(
                      `https://api.twitch.tv/helix/users?id=${follow.user_id}`,
                      { headers }
                    );
                    
                    if (userResponse.ok) {
                      const userData = await userResponse.json();
                      if (userData.data && userData.data.length > 0) {
                        avatar = userData.data[0].profile_image_url;
                      }
                    }
                  } catch (avatarError) {
                    console.error('Error fetching follower avatar:', avatarError.message);
                  }
                  
                  // Handle the follow event
                  handleTwitchEvent('follow', {
                    username: follow.user_login,
                    displayName: follow.user_name,
                    avatar: avatar
                  });
                }
                
                if (newFollowCount > 0) {
                  }
              }
            } else {
              console.error('▶ Invalid followers response format');
            }
          } else {
            // If we get a 401 or 403, it might be a missing scope
            if (followersResponse.status === 401 || followersResponse.status === 403) {
              console.error(`▶ Twitch followers API error: ${followersResponse.status}. Make sure your token has the moderator:read:followers scope.`);
            } else {
              console.error(`▶ Twitch followers API error: ${followersResponse.status}`);
            }
          }
        } catch (followerError) {
          console.error('▶ Error checking Twitch followers:', followerError.message);
        }
      }
      
      // 2. CHECK FOR NEW SUBSCRIPTIONS
      // Check less frequently than followers to avoid API rate limits
      if (now - lastSubscribersCheck >= 60000) { // Every 60 seconds
        lastSubscribersCheck = now;
        // Check for required scope
        if (!validateResponse.ok || !validateData || !validateData.scopes || !validateData.scopes.includes('channel:read:subscriptions')) {
          console.error('▶ Missing required scope: channel:read:subscriptions');
          console.error('▶ Skipping subscription check');
        } else {
          try {
            const subsResponse = await fetch(
              `https://api.twitch.tv/helix/subscriptions?broadcaster_id=${twitchChannelId}&first=20`,
              { headers }
            );
            
            if (subsResponse.ok) {
              const subsData = await subsResponse.json();
              
              if (subsData.data && Array.isArray(subsData.data)) {
                // On first run, just store all subscribers without triggering events
                if (window.knownSubscribers.size === 0) {
                  for (const sub of subsData.data) {
                    const subKey = `${sub.user_id}-${sub.tier}`;
                    window.knownSubscribers.add(subKey);
                  }
                } else {
                  let newSubCount = 0;
                  
                  for (const sub of subsData.data) {
                    // Skip if we've already processed this subscriber
                    const subKey = `${sub.user_id}-${sub.tier}`;
                    if (window.knownSubscribers.has(subKey)) continue;
                    
                    // Add to known subscribers set
                    window.knownSubscribers.add(subKey);
                    newSubCount++;
                    
                    // Only process subs from the last 10 minutes to avoid spam on startup
                    const startupTime = window.startupTime || Date.now();
                    const timeSinceStartup = now - startupTime;
                    if (timeSinceStartup > 600000) {
                      continue;
                    }
                    
                    // Get user avatar using the centralized function
                    let avatar = '';
                    try {
                      const userResponse = await fetch(
                        `https://api.twitch.tv/helix/users?id=${sub.user_id}`,
                        { headers }
                      );
                      
                      if (userResponse.ok) {
                        const userData = await userResponse.json();
                        if (userData.data && userData.data.length > 0) {
                          avatar = userData.data[0].profile_image_url;
                        }
                      }
                    } catch (avatarError) {
                      console.error('Error fetching subscriber avatar:', avatarError.message);
                    }
                    
                    // Handle the subscription event
                    handleTwitchEvent('subscription', {
                      username: sub.user_login,
                      displayName: sub.user_name,
                      avatar: avatar,
                      tier: sub.tier,
                      isGift: sub.is_gift,
                      months: parseInt(subsData.data[0].cumulative_months || '1')
                    });
                  }
                  
                  if (newSubCount > 0) {
                    }
                }
              } else {
                console.error('▶ Invalid subscriptions response format');
              }
            } else {
              // If we get a 401 or 403, it might be a missing scope
              if (subsResponse.status === 401 || subsResponse.status === 403) {
                console.error(`▶ Twitch subscriptions API error: ${subsResponse.status}. Make sure your token has the channel:read:subscriptions scope.`);
              } else {
                console.error(`▶ Twitch subscriptions API error: ${subsResponse.status}`);
              }
            }
          } catch (subsError) {
            console.error('▶ Error checking Twitch subscriptions:', subsError.message);
          }
        }
      }
      
       
      // Clean up old entries if sets get too large
      if (window.knownFollowers && window.knownFollowers.size > 1000) {
        const oldestFollowers = Array.from(window.knownFollowers).slice(0, 200);
        oldestFollowers.forEach(id => window.knownFollowers.delete(id));
        }
      
      if (window.knownSubscribers && window.knownSubscribers.size > 1000) {
        const oldestSubscribers = Array.from(window.knownSubscribers).slice(0, 200);
        oldestSubscribers.forEach(id => window.knownSubscribers.delete(id));
        }
      
      if (window.knownCheerers && window.knownCheerers.size > 1000) {
        const oldestCheerers = Array.from(window.knownCheerers).slice(0, 200);
        oldestCheerers.forEach(id => window.knownCheerers.delete(id));
        }
    } catch (error) {
      console.error('▶ Error in consolidated Twitch events check:', error.message);
      console.error('▶ Error stack:', error.stack);
    }
  }
  
  // Legacy function for backward compatibility - now just calls the consolidated function
  async function checkTwitchFollowers() {
    await checkTwitchEvents();
  }
  
  // Legacy function for backward compatibility - now just calls the consolidated function
  async function checkTwitchSubscriptions() {
    await checkTwitchEvents();
  }
  
  // Legacy function for backward compatibility - now just calls the consolidated function
  async function checkTwitchBits() {
    await checkTwitchEvents();
  }
  
  // Handle Twitch events
  async function processTwitchEvents() {
    try {
      // Ensure we have a token
      if (!TOKENS?.twitch?.access_token) {
        return;
      }
      
      // Get channel ID if we don't have it
      if (!twitchChannelId) {
        const channelInfo = await getTwitchChannelInfo();
        if (!channelInfo || !channelInfo.id) {
          console.error('▶ Could not get Twitch channel ID');
          return;
        }
        twitchChannelId = channelInfo.id;
        }
      
      // Use the consolidated function to check for all Twitch events
      try {
        await checkTwitchEvents();
        } catch (error) {
        console.error('Error in checkTwitchEvents:', error);
      }
      
      // Limit the size of our tracking sets to prevent memory issues
      if (knownFollowers.size > 1000) {
        const oldestFollowers = Array.from(knownFollowers).slice(0, 200);
        oldestFollowers.forEach(id => knownFollowers.delete(id));
      }
      
      if (knownSubscribers.size > 1000) {
        const oldestSubscribers = Array.from(knownSubscribers).slice(0, 200);
        oldestSubscribers.forEach(id => knownSubscribers.delete(id));
      }
      
      if (knownCheerers.size > 1000) {
        const oldestCheerers = Array.from(knownCheerers).slice(0, 200);
        oldestCheerers.forEach(id => knownCheerers.delete(id));
      }
    } catch (error) {
      console.error('Error processing Twitch events:', error);
    }
  }

  // TikTok WS (Tikfinity)
  try {
    const tkWs = new WebSocket('ws://localhost:21213/');
    let tF = 0, tD = 0, tS = 0;
    const giftTimers  = {};
    const giftMaxEvents = {};
    
    // Track TikTok connection status
    tkWs.onopen = () => {
      updateConnectionStatus('tiktok', true);
      };
    
    tkWs.onclose = () => {
      updateConnectionStatus('tiktok', false);
      };
    
    tkWs.onerror = (error) => {
      updateConnectionStatus('tiktok', false);
      console.error('▶ TikTok WebSocket error:', error);
    };

    // Global function to handle TikTok messages (for both WebSocket and test events)
    window.handleTikTokMessage = function(m) {
      const d = m.data || m;
      if (m.event === 'roomUser') {
        $('#tiktokViewers').text(d.viewerCount);
      } else if (m.event === 'like') {
        $('#tiktokLikes').text(d.totalLikeCount);
      } else if (m.event === 'follow') {
        tF++; $('#tiktokFollows').text(tF);
        addItem({ avatar: d.profilePictureUrl, name: d.uniqueId, html: 'FOLLOWED', provider: 'tiktok' });
      } else if (m.event === 'subscribe' || m.event === 'subscription') {
        // Log the full subscription data for debugging
        // Check if this is a gift subscription based on the protobuff data structure
        // According to Tikfinity devs, gift subs have old_subscribe_status.value = 1
        const isGiftSub = d.old_subscribe_status && 
                         d.old_subscribe_status.value === 1 && 
                         d.subscribe_message_type === null;
        
        // Check for explicit gift type indicators
        const hasExplicitGiftType = (d.giftType === 1 && d.senderUniqueId);
        
        // Check for receiver-only gift (older method)
        const isReceiverOnlyGift = !d.giftType && d.receiverUniqueId;
        
        // Check for SubWaveEvent pattern as mentioned in the screenshot
        const hasSubWaveEvent = d.event_type === 'SubWaveEvent' || 
                              (d.base_message && d.base_message.serialized_on_wire === true);
        
        // Check for thanks list pattern as mentioned in the screenshot
        const hasThanksListIndicator = d.subscribing_status && 
                                     d.subscribing_status.name === 'SUBSCRIBING_STATUS_CIRCLE' && 
                                     d.subscribing_status.value === 2;
        
        if (isGiftSub || hasExplicitGiftType || isReceiverOnlyGift || hasSubWaveEvent || hasThanksListIndicator) {
          // This is a gift subscription
          const recv = d.receiverUniqueId || d.uniqueId;
          const from = d.senderUniqueId || '(unknown sender)';
          
          addItem({ 
            avatar: d.senderProfilePictureUrl || d.profilePictureUrl, 
            name: from, 
            html: `GIFT SUB from ${from} → ${recv}`, 
            provider: 'tiktok' 
          });
        } else {
          // Regular subscription
          addItem({ 
            avatar: d.profilePictureUrl, 
            name: d.uniqueId, 
            html: 'NEW SUB', 
            provider: 'tiktok' 
          });
        }
        
        tS++; $('#tiktokSubs').text(tS);
      } else if (m.event === 'gift') {
        // Only show after stacking is complete for Type 1 gifts
        if (d.giftType === 1 && !d.repeatEnd) return;
        
        const count = d.repeatCount || 1;
        const totalDiamonds = (d.diamondCount || 0) * count;
        const icon = d.giftPictureUrl || d.giftImageUrl || '';
        const displayName = d.nickname || d.uniqueId || 'Unknown';
        
        // Create a unique ID for each gift to ensure a new entry is created
        const uniqueGiftId = `${displayName}-${d.giftId}-${Date.now()}`;
        
        // Create HTML for the gift
        const giftHtml = `sent ${count}× ${d.giftName} ${icon ? `<img class="icon" src="${icon}">` : ''}<br><span style='font-size:0.7em;color:#FFD700;'>(${totalDiamonds} diamonds)</span>`;
        
        // Always add a new item for each gift
        addItem({
          avatar: d.profilePictureUrl || d.avatarUrl, 
          name: displayName, 
          html: giftHtml, 
          provider: 'tiktok',
          giftImageUrl: icon, // Pass the gift image URL
          giftName: d.giftName,
          giftCount: count,
          diamondCount: totalDiamonds
        });
        
        // Update diamond counter
        tD += totalDiamonds;
        $('#tiktokDiamonds').text(tD);
        
        // Scroll to bottom to show the new gift
        $('.feed').scrollTop($('.feed')[0].scrollHeight);
      }
    };
    
    // Wire up the WebSocket to use the handler
    tkWs.onmessage = e => {
      const m = JSON.parse(e.data);
      window.handleTikTokMessage(m);
    };
  } catch(err) { 
    console.error('TikTok WS error', err);
    updateConnectionStatus('tiktok', false);
  }

  window.electron.ipcRenderer.on('twitch-connection-status', (event, data) => {
    console.log('[Overlay] Received Twitch connection status update:', data);
    const status = data.connectionStatus !== undefined ? data.connectionStatus : data;
    updateConnectionStatus('twitch', status);
    if (status === true) {
      twitchServiceRunning = true;
    } else {
      twitchServiceRunning = false;
    }
  });

  window.electron.ipcRenderer.on('twitch-data-update', (event, data) => {
    console.log('🔥 [Overlay] IPC LISTENER CALLED! Event received successfully!');
    console.log('[Overlay] Received Twitch data update:', data);
    
    // Update viewer count
    if (data.viewerCount !== undefined) {
      document.getElementById('twitchViewers').textContent = data.viewerCount || '–';
    }

    // Process new events
    if (data && data.events && data.events.length > 0) {
      console.log(`[Overlay] Received ${data.events.length} Twitch events`);
      data.events.forEach(event => {
        console.log(`[Overlay] Processing Twitch event: ${event.type} from ${event.displayName || event.username}`);
        
        // FILTER OUT REGULAR CHAT MESSAGES
        if (event.type === 'chat' || event.type === 'message') {
          console.log(`[Overlay] FILTERING OUT Twitch chat message from ${event.displayName}`);
          return; // Skip regular chat messages in overlay
        }
        
// Map Twitch service event types to overlay event types
let overlayEventType = event.type;
if (event.type === 'follower') {
  overlayEventType = 'follow'; // Map follower events to follow for handleTwitchEvent
}

console.log(`[Overlay] Event type mapping: ${event.type} -> ${overlayEventType}`);
        
        // Prepare event data with proper mapping for handleTwitchEvent
        const mappedEventData = {
          ...event,
          // Ensure avatar and displayName are available
          avatar: event.author?.avatar || event.avatar || '',
          displayName: event.author?.name || event.displayName || event.username || '',
          // Map viewer count for raids
          viewers: event.viewerCount || event.viewers || 0,
          // Map bits amount for bits events
          bits: event.amount || event.bits || 0
        };
        
        // Pass the original event type from the API service
        handleTwitchEvent(overlayEventType, mappedEventData);
      });
    } else {
      console.log('[Overlay] No Twitch events to process');
    }

    // Update connection status
    updateConnectionStatus('twitch', data.connectionStatus);
  });

  // Function to handle YouTube events and add them to the feed
  function handleYouTubeEvent(eventType, eventData) {
    console.log(`[Overlay] Handling YouTube event: ${eventType}`, eventData);
    console.log(`[Overlay] Avatar: "${eventData.avatar}", DisplayName: "${eventData.displayName}", Username: "${eventData.username}"`);
    
    let html = '';
    let displayName = eventData.displayName || eventData.username || 'Unknown User';
    
    console.log(`[Overlay] Final displayName: "${displayName}"`);
    
    switch(eventType) {
      case 'superchat':
        html = `SUPER CHAT<br><span style="font-size:0.7em;color:#FFD700">(${eventData.amount || ''})</span>`;
        break;
      case 'supersticker':
        html = `SUPER STICKER<br><span style="font-size:0.7em;color:#FFD700">(${eventData.amount || ''})</span>`;
        break;
      case 'sponsor':
        if (eventData.gifted) {
          if (eventData.giftCount) {
            html = `GIFTED ${eventData.giftCount} MEMBERSHIPS`;
          } else {
            html = `MEMBERSHIP GIFT`;
          }
          if (eventData.memberLevelName) {
            html += ` (${eventData.memberLevelName})`;
          }
        } else {
          html = `NEW MEMBER`;
          if (eventData.memberLevelName) {
            html += ` (${eventData.memberLevelName})`;
          }
          if (eventData.isUpgrade) {
            html = `MEMBERSHIP UPGRADE (${eventData.memberLevelName || 'Member'})`;
          }
        }
        break;
      case 'milestone':
        html = `MEMBERSHIP MILESTONE`;
        if (eventData.memberMonth) {
          html += ` (${eventData.memberMonth} months)`;
        }
        if (eventData.message) {
          html += `: ${eventData.message}`;
        }
        break;
      case 'gift_membership_purchase':
        html = `GIFTED ${eventData.giftCount || 1} MEMBERSHIPS`;
        if (eventData.memberLevelName) {
          html += ` (${eventData.memberLevelName})`;
        }
        break;
      case 'subscription':
        html = 'SUBSCRIBED!';
        break;
      default:
        html = `${eventType.toUpperCase()}`;
        if (eventData.message) {
          html += `: ${eventData.message}`;
        }
    }

    // Determine avatar and name to use
    let avatarToUse = eventData.avatar || '';
    let nameToUse = displayName;

    // Use gray circle for null avatars (e.g., Stream Elements subscriptions)
    if (!avatarToUse) {
      avatarToUse = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjAiIGN5PSIyMCIgcj0iMjAiIGZpbGw9IiM4ODg4ODgiLz4KPHN2Zz4K';
    }

    let extraClass = '';
    if (eventType === 'gift_membership_purchase') {
      extraClass = 'gift-membership';
    } else if (eventType === 'superchat' || eventType === 'supersticker') {
      extraClass = 'superchat';
    }

    addItem({
      avatar: avatarToUse,
      name: nameToUse,
      html: html,
      provider: 'youtube',
      extraClass: extraClass
    });

    // Update counters based on event type
    if (eventType === 'superchat' || eventType === 'supersticker') {
      const currentCount = parseInt(document.getElementById('ytSuperchats').textContent) || 0;
      document.getElementById('ytSuperchats').textContent = currentCount + 1;
    } else if (eventType === 'sponsor' || eventType === 'milestone' || eventType === 'gift_membership_purchase') {
      const currentCount = parseInt(document.getElementById('ytMembers').textContent) || 0;
      document.getElementById('ytMembers').textContent = currentCount + 1;
    } else if (eventType === 'subscription') {
      const currentCount = parseInt(document.getElementById('ytSubscribers').textContent) || 0;
      document.getElementById('ytSubscribers').textContent = currentCount + 1;
    }
  }

  // Make functions globally accessible
  window.handleYouTubeEvent = handleYouTubeEvent;

  // Function to handle Twitch events
  function handleTwitchEvent(eventType, eventData) {
    console.log(`[Overlay] Handling Twitch event: ${eventType}`, eventData);
    
    let html = '';
    let displayName = eventData.displayName || eventData.username || 'Unknown User';
    
    switch(eventType) {
      case 'follow':
        html = 'FOLLOWED';
        break;
      case 'subscriber':
        html = `NEW SUBSCRIBER`;
        if (eventData.months && eventData.months > 1) {
          html = `RESUB (${eventData.months} months)`;
        }
        if (eventData.tier && eventData.tier !== '1000') {
          const tierName = eventData.tier === '2000' ? 'Tier 2' : eventData.tier === '3000' ? 'Tier 3' : `Tier ${eventData.tier}`;
          html += ` - ${tierName}`;
        }
        break;
      case 'gift_subscription':
        html = `GIFT SUB from ${eventData.gifter}`;
        if (eventData.tier && eventData.tier !== '1000') {
          const tierName = eventData.tier === '2000' ? 'Tier 2' : eventData.tier === '3000' ? 'Tier 3' : `Tier ${eventData.tier}`;
          html += ` - ${tierName}`;
        }
        break;
      case 'gift_purchase':
        html = `GIFTED ${eventData.giftCount || 1} SUBS`;
        if (eventData.tier && eventData.tier !== '1000') {
          const tierName = eventData.tier === '2000' ? 'Tier 2' : eventData.tier === '3000' ? 'Tier 3' : `Tier ${eventData.tier}`;
          html += ` - ${tierName}`;
        }
        break;
      case 'bits':
        html = `CHEERED<br><span style="font-size:0.7em;color:#FFD700">(${eventData.amount || eventData.bits} bits)</span>`;
        break;
      case 'raid':
        html = `RAID with <span style="color:#0F9D58">${eventData.viewerCount || eventData.viewers} viewers</span>`;
        break;
      case 'channel_point_redemption':
        html = `REDEEMED <span style="color:#0F9D58">${eventData.rewardTitle}</span>: ${eventData.message}`;
        break;
      default:
        html = `${eventType.toUpperCase()}`;
        if (eventData.message) {
          html += `: ${eventData.message}`;
        }
    }

    // Add the item to the feed
    addItem({
      avatar: eventData.avatar || '',
      name: displayName,
      html: html,
      provider: 'twitch'
    });

    // Update counters based on event type
    if (eventType === 'follow') {
      tF++; document.getElementById('twitchFollows').textContent = tF;
    } else if (eventType === 'subscriber' || eventType === 'gift_subscription' || eventType === 'gift_purchase') {
      tS++; document.getElementById('twitchSubs').textContent = tS;
    } else if (eventType === 'bits') {
      tB += (eventData.amount || eventData.bits || 0); document.getElementById('twitchBits').textContent = tB;
    } else if (eventType === 'raid') {
      tR += (eventData.viewerCount || eventData.viewers || 0); document.getElementById('twitchRaids').textContent = tR;
    }
  }

  // Make functions globally accessible
  window.handleTwitchEvent = handleTwitchEvent;

  // Token reload listener for auth refresh
  window.electron.ipcRenderer.on('reload-tokens', async () => {
    console.log('🔄 [Overlay] Reloading tokens from secure storage...');
    TOKENS = await window.electron.ipcRenderer.invoke('get-tokens');
    console.log('✅ [Overlay] Tokens reloaded successfully');
  });

  // Connection status listeners for service status updates
  window.electron.ipcRenderer.on('twitch-connection-status', (event, data) => {
    console.log('[Overlay] Received Twitch connection status update:', data);
    const status = data.connectionStatus !== undefined ? data.connectionStatus : data;
    updateConnectionStatus('twitch', status);
    twitchServiceRunning = data.connectionStatus;
  });

  window.electron.ipcRenderer.on('youtube-connection-status', (event, data) => {
    console.log('[Overlay] Received YouTube connection status update:', data);
    console.log('[Overlay] data.connectionStatus value:', data.connectionStatus);
    console.log('[Overlay] data.connectionStatus type:', typeof data.connectionStatus);
    console.log('[Overlay] About to call updateConnectionStatus with:', 'youtube', data.connectionStatus);
    updateConnectionStatus('youtube', data.connectionStatus);
    console.log('[Overlay] updateConnectionStatus call completed');
    youtubeServiceRunning = data.connectionStatus;
  });

  window.electron.ipcRenderer.on('youtube-data-update', (event, data) => {
    console.log('🔥 [Overlay] IPC LISTENER CALLED! Event received successfully!');
    console.log('[Overlay] Received YouTube data update:', data);
    
    // Update viewer count
    if (data.viewerCount !== undefined) {
      document.getElementById('ytViewers').textContent = data.viewerCount || '–';
    }

    // Process new events
    if (data && data.events && data.events.length > 0) {
      console.log(`[Overlay] Received ${data.events.length} YouTube events`);
      data.events.forEach(event => {
        console.log(`[Overlay] Processing event: ${event.type} from ${event.displayName || event.username}`);
        
        // FILTER OUT REGULAR CHAT MESSAGES
        if (event.type === 'textMessageEvent' || event.type === 'chat') {
          console.log(`[Overlay] FILTERING OUT YouTube chat message from ${event.displayName}`);
                    // STREAMELEMENTS SUBSCRIPTION DETECTION - Check before filtering out
                    if ((event.displayName === 'StreamElements' || event.displayName === 'Streamelements') && event.message) {
            console.log(`[Overlay] StreamElements message detected: "${event.message}"`);
            
            // Check for exact StreamElements subscription pattern
            if (event.message.endsWith(' just subscribed!')) {
              const subscriberName = event.message.replace(' just subscribed!', '').trim();
              console.log(`[Overlay] 🎉 YOUTUBE SUBSCRIPTION DETECTED! Subscriber: ${subscriberName}`);
              
              // Create subscription event and call handleYouTubeEvent
              handleYouTubeEvent('subscription', {
                displayName: subscriberName,
                username: subscriberName,
                avatar: '', // StreamElements subs don't have subscriber avatar
                message: event.message,
                source: 'StreamElements'
              });
            }
          }
          return; // Skip regular chat messages in overlay
        }
        
        console.log(`[Overlay] Passing through event type: ${event.type} (no mapping needed)`);
        
        // Prepare event data with proper mapping for handleYouTubeEvent
        const mappedEventData = {
          ...event,
          // Ensure avatar and displayName are available
          avatar: event.author?.avatar || event.avatar || '',
          displayName: event.author?.name || event.displayName || event.username || '',
          // Map viewer count for raids
          viewers: event.viewerCount || event.viewers || 0,
          // Map bits amount for bits events
          bits: event.amount || event.bits || 0
        };
        
        // Pass the original event type from the API service
        handleYouTubeEvent(event.type, mappedEventData);
      });
    } else {
      console.log('[Overlay] No YouTube events to process');
    }

    // Update connection status
    updateConnectionStatus('youtube', data.connectionStatus);
  });

  // Function to update connection status for a platform
  function updateConnectionStatus(platform, status) {
    console.log(`[updateConnectionStatus] Called with platform: ${platform}, status: ${status}`);
    const statusElement = document.getElementById(`${platform}-status`);
    console.log(`[updateConnectionStatus] Found element:`, statusElement);
    if (statusElement) {
      console.log(`[updateConnectionStatus] Element classes before update:`, statusElement.classList.toString());
      if (status === true) {
        statusElement.classList.remove('status-disconnected');
        statusElement.classList.add('status-connected');
        console.log(`[updateConnectionStatus] Added status-connected class`);
      } else {
        statusElement.classList.remove('status-connected');
        statusElement.classList.add('status-disconnected');
        console.log(`[updateConnectionStatus] Added status-disconnected class`);
      }
      console.log(`[updateConnectionStatus] Element classes after update:`, statusElement.classList.toString());
    } else {
      console.error(`[updateConnectionStatus] ❌ Element with ID '${platform}-status' not found!`);
    }
  }

  // Function to send event to API via IPC
  function sendEventToAPI(item) {
    try {
      // Extract event type from the HTML content
      let eventType = 'unknown';
      let amount = null;
      let message = null;
      
      const htmlLower = item.html.toLowerCase();
      
      // Twitch events
      if (item.provider === 'twitch') {
        if (htmlLower.includes('followed')) eventType = 'follow';
        else if (htmlLower.includes('gifted') && htmlLower.includes('subs')) eventType = 'gift_purchase';
        else if (htmlLower.includes('gift sub')) eventType = 'gift_subscription';
        else if (htmlLower.includes('new subscriber') || htmlLower.includes('resub') || htmlLower.includes('subscriber')) eventType = 'subscription';
        else if (htmlLower.includes('cheered')) {
          eventType = 'bits';
          // Extract bits amount from "CHEERED<br><span>(X bits)</span>" pattern
          const bitsMatch = item.html.match(/\((\d+)\s*bits\)/i);
          if (bitsMatch) amount = parseInt(bitsMatch[1]);
        }
        else if (htmlLower.includes('raid')) {
          eventType = 'raid';
          // Extract viewer count from "RAID with X viewers" pattern
          const viewerMatch = item.html.match(/(\d+)\s*viewers/i);
          if (viewerMatch) amount = parseInt(viewerMatch[1]);
        }
        else if (htmlLower.includes('redeemed')) eventType = 'channel_point_redemption';
      }
      // YouTube events
      else if (item.provider === 'youtube') {
        if (htmlLower.includes('super chat')) {
          eventType = 'superchat';
          // Extract amount from "SUPER CHAT<br><span>(amount)</span>" pattern
          const amountMatch = item.html.match(/\(([^)]+)\)/i);
          if (amountMatch) {
            message = amountMatch[1]; // Store amount as message for display
            // Also try to extract numeric amount for potential future use
            const numericMatch = amountMatch[1].match(/[\d.]+/);
            if (numericMatch) amount = parseFloat(numericMatch[0]);
          }
        }
        else if (htmlLower.includes('super sticker')) {
          eventType = 'supersticker';
          // Extract amount from "SUPER STICKER<br><span>(amount)</span>" pattern
          const amountMatch = item.html.match(/\(([^)]+)\)/i);
          if (amountMatch) {
            message = amountMatch[1]; // Store amount as message for display
            // Also try to extract numeric amount for potential future use
            const numericMatch = amountMatch[1].match(/[\d.]+/);
            if (numericMatch) amount = parseFloat(numericMatch[0]);
          }
        }
        else if (htmlLower.includes('gifted') && htmlLower.includes('membership')) eventType = 'gift_membership_purchase';
        else if (htmlLower.includes('new member') || htmlLower.includes('membership')) eventType = 'membership';
        else if (htmlLower.includes('milestone')) eventType = 'milestone';
        else if (htmlLower.includes('subscribed')) eventType = 'subscription';
      }
      // TikTok events
      else if (item.provider === 'tiktok') {
        if (htmlLower.includes('followed')) eventType = 'follow';
        else if (htmlLower.includes('sent') && htmlLower.includes('×') && htmlLower.includes('diamonds')) eventType = 'gift';
        else if (htmlLower.includes('gift sub')) eventType = 'subscription';
        else if (htmlLower.includes('new sub') || htmlLower.includes('subscribed')) eventType = 'subscription';
        
        // For TikTok gifts, extract additional data
        if (eventType === 'gift') {
          // Extract gift count from "sent 5× GiftName" pattern
          const countMatch = item.html.match(/sent (\d+)×/);
          if (countMatch) amount = parseInt(countMatch[1]);
          
          // Extract gift name from "sent 5× GiftName" pattern
          const nameMatch = item.html.match(/sent \d+×\s*([^<]+)/);
          if (nameMatch) {
            message = nameMatch[1].trim();
          }
        }
      }
      
      // Extract message if present (but don't override TikTok gift data)
      if (item.html.includes(':') && eventType !== 'gift') {
        const parts = item.html.split(':');
        if (parts.length > 1) {
          message = parts.slice(1).join(':').trim();
        }
      }
      
      // Build standardized event object
      const eventData = {
        platform: item.provider,
        type: eventType,
        username: item.name,
        displayName: item.name,
        avatar: item.avatar || '',
        timestamp: new Date().toISOString()
      };
      
      // Add optional fields if present
      if (amount) eventData.amount = amount;
      if (message) eventData.message = message;
      
      // For TikTok gifts, add gift-specific data
      if (item.provider === 'tiktok' && eventType === 'gift') {
        if (item.giftImageUrl) eventData.giftImageUrl = item.giftImageUrl;
        if (item.giftName) eventData.giftName = item.giftName;
        if (item.giftCount) eventData.amount = item.giftCount; // Use giftCount as amount
        if (item.diamondCount) eventData.diamondCount = item.diamondCount;
        
        // If we extracted gift name from HTML, also set it as giftName field
        if (message && !item.giftName) {
          eventData.giftName = message;
        }
        
        // Also preserve the full HTML as message if no gift name was extracted
        if (!message) {
          eventData.message = item.html;
        }
      }
      
      // For YouTube gift memberships, extract gift count from HTML
      if (item.provider === 'youtube' && eventType === 'gift_membership_purchase') {
        // Extract gift count from HTML like "GIFTED 5 MEMBERSHIPS"
        const giftCountMatch = item.html.match(/GIFTED\s+(\d+)\s+MEMBERSHIP/i);
        if (giftCountMatch) {
          eventData.giftCount = parseInt(giftCountMatch[1], 10);
          console.log(`[Overlay] Extracted giftCount: ${eventData.giftCount} from HTML: ${item.html}`);
        }
      }
      
      // For Twitch gift subscriptions, extract gift count from HTML
      if (item.provider === 'twitch' && eventType === 'gift_purchase') {
        // Extract gift count from HTML like "GIFTED 5 SUBS"
        const giftCountMatch = item.html.match(/GIFTED\s+(\d+)\s+SUBS/i);
        if (giftCountMatch) {
          eventData.giftCount = parseInt(giftCountMatch[1], 10);
          console.log(`[Overlay] Extracted giftCount: ${eventData.giftCount} from HTML: ${item.html}`);
        }
      }
      
      // Debug logging for API event formatting
      console.log(`[Overlay] Sending ${eventData.platform} ${eventData.type} event to API:`, eventData);
      
      // Send to main process
      window.electron.ipcRenderer.send('stream-event', eventData);
      
    } catch (error) {
      console.error('[Overlay] Error sending event to API:', error);
    }
  }
  
  // Function to add an item to the feed
  function addItem(item) {
    const $feed = $('.feed');
    const $item = $(`<div class="event-row">
      <div class='provider-icon-box'><img src='${item.provider === 'twitch' ? 'https://static.twitchcdn.net/assets/favicon-32-e29e246c157142c94346.png' : item.provider === 'youtube' ? 'https://www.youtube.com/favicon.ico' : 'https://www.tiktok.com/favicon.ico'}' alt='${item.provider}'></div>
      <div class="item ${item.provider}-item ${item.extraClass || ''}">
        <img class="avatar" src="${item.avatar}" alt="">
        <div class="username">${item.name}</div>
        <div class="details">${item.html}</div>
      </div>
    </div>`);
    $feed.append($item);
    $feed.each(function() { this.scrollTop = this.scrollHeight; });
    
    // Limit to 30 most recent events
    while ($feed.children('.event-row').length > 30) {
      $feed.children('.event-row').first().remove();
    }
    
    // Send event to main process for API storage
    sendEventToAPI(item);
  }
  
  // Handle font size updates
  window.electron.ipcRenderer.on('font-size-update', (event, fontSizes) => {
    // Clear existing dynamic styles
    const existingStyles = document.querySelectorAll('style[data-dynamic-font]');
    existingStyles.forEach(style => style.remove());
    
    // Apply overlay event box size
    if (fontSizes.overlayFontSize) {
      const style = document.createElement('style');
      style.setAttribute('data-dynamic-font', 'true');
      style.textContent = `
        .item { 
          min-height: calc(44px * ${fontSizes.overlayFontSize}) !important;
          padding: calc(0.5em * ${fontSizes.overlayFontSize}) !important;
        }
        .item .left-content {
          font-size: calc(1em * ${fontSizes.overlayFontSize}) !important;
        }
        .item .right-content {
          font-size: calc(1em * ${fontSizes.overlayFontSize}) !important;
        }
      `;
      document.head.appendChild(style);
    }
    
    // Apply stats font size
    if (fontSizes.statsFontSize) {
      const style = document.createElement('style');
      style.setAttribute('data-dynamic-font', 'true');
      style.textContent = `.stat span { font-size: ${fontSizes.statsFontSize}em !important; }`;
      document.head.appendChild(style);
    }
    
    console.log('Overlay font sizes updated:', fontSizes);
  });

  // Handle background color updates from settings
  window.electron.ipcRenderer.on('background-color-update', (event, backgroundColor) => {
    console.log('Overlay background color updated to:', backgroundColor);
    
    // Remove existing dynamic background color style if present
    const existingStyle = document.getElementById('dynamic-background-color-style');
    if (existingStyle) {
      existingStyle.remove();
    }
    
    // Add new background color style
    const style = document.createElement('style');
    style.id = 'dynamic-background-color-style';
    style.textContent = `
      html, body { 
        background-color: ${backgroundColor} !important; 
      }
      .stats-wrapper {
        background: ${backgroundColor} !important;
        border-bottom: 3px solid #8000FF !important;
        box-shadow: none !important;
      }
      .feed-header {
        background: ${backgroundColor} !important;
        border-bottom: 1px solid #8000FF !important;
      }
      .item {
        background: ${backgroundColor} !important;
      }
    `;
    document.head.appendChild(style);
  });

  // Handle events color updates from settings
  window.electron.ipcRenderer.on('events-color-update', (event, eventsColor) => {
    console.log('Overlay events color updated to:', eventsColor);
    
    // Remove existing dynamic events color style if present
    const existingStyle = document.getElementById('dynamic-events-color-style');
    if (existingStyle) {
      existingStyle.remove();
    }
    
    // Add new events color style
    const style = document.createElement('style');
    style.id = 'dynamic-events-color-style';
    style.textContent = `
      /* Update main text color */
      html, body { 
        color: ${eventsColor} !important; 
      }
      
      /* Update stat labels */
      .stat label { 
        color: ${eventsColor} !important; 
      }
      
      /* Update stat borders and backgrounds */
      .stat { 
        border: 2px solid ${eventsColor} !important; 
        background: ${eventsColor}1A !important; 
      }
      
      /* Update stats wrapper border */
      .stats-wrapper {
        border-bottom: 3px solid ${eventsColor} !important;
      }
      
      /* Update feed header border */
      .feed-header {
        border-bottom: 1px solid ${eventsColor} !important;
      }
      
      /* Update item borders */
      .item {
        border: 1px solid ${eventsColor} !important;
      }
      
      /* Update provider icon box background */
      .provider-icon-box {
        background: ${eventsColor} !important;
      }
      
      /* Update platform icon filter */
      .platform-icon-inline {
        filter: drop-shadow(0 0 2px ${eventsColor}) !important;
      }
      
      /* Update button colors */
      .stat.polling button {
        color: ${eventsColor} !important;
        border: 1px solid ${eventsColor} !important;
      }
    `;
    document.head.appendChild(style);
  });

  // Mark initialization as complete
  console.log('[Overlay] Initialization complete - buttons are now active');
  isInitialized = true;

})();
</script>
</body>
</html>
