<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HoellStream - Stream Events</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    html, body {
      height: 100%; margin: 0; padding: 0;
      background: #000; color: #B266FF;
      font-family: 'Press Start 2P', sans-serif;
      display: flex; flex-direction: column; overflow: hidden;
    }
    .stats-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1em 0;
      background: rgba(0,0,0,0.95);
      border-bottom: 3px solid #8000FF;
      box-shadow: inset 0 0 0 14px #000, 0 0 12px #000C;
    }
    .platform-row {
      display: grid;
      grid-template-columns: 40px repeat(5, 180px);
      column-gap: 24px;
      margin-bottom: 0.5em;
      justify-content: center;
      white-space: nowrap;
    }
    /* Platform icon container with status indicator */
    .platform-icon-container {
      position: relative;
      width: 32px; height: 32px;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-right: 8px;
    }
    
    .platform-icon-inline {
      width: 24px; height: 24px;
      filter: drop-shadow(0 0 2px #8000FF);
      z-index: 2;
    }
    
    /* Connection status indicator */
    .connection-status {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      z-index: 1;
      transition: background-color 0.3s ease;
    }
    
    .status-connected {
      background-color: rgba(0, 255, 0, 0.3);
      box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
    }
    
    .status-disconnected {
      background-color: rgba(255, 0, 0, 0.3);
      box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
    }
    .stat {
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      width: 180px; height: 60px;
      padding: 0.4em;
      border: 2px solid #8000FF; border-radius: 6px;
      background: rgba(128,0,255,0.1);
      box-shadow: inset 0 0 4px #000;
      text-align: center;
    }
    .stat label { color: #B266FF; font-size: 0.9em; margin-bottom: 0.2em; white-space: nowrap; }
    .stat span  { color: #FFF; font-weight: bold; font-size: 1.2em; }
    .stat.polling { padding: 0.4em; }
    .stat.polling button {
      width: 100%; font-family: 'Press Start 2P'; font-size: 0.75em;
      color: #B266FF; background: transparent;
      border: 1px solid #B266FF; border-radius: 4px;
      padding: 0.3em; margin: 0.1em 0; cursor: pointer;
      white-space: nowrap;
    }
    .feed-header {
      position: sticky; top: 0;
      background: rgba(0,0,0,0.95);
      padding: 0.5em; border-bottom: 1px solid #8000FF;
      text-align: center; font-size: 1.25em; font-weight: bold;
      z-index: 10;
    }
    .feed {
      flex:1; overflow-y:auto;
      padding:0.5em; width:90vw; margin:0 auto;
    }
    .item {
      display:flex; align-items:center;
      margin:0.5em auto; padding:0.5em;
      border:1px solid #8000FF; border-radius:4px;
      width:80vw;
    }
    .item.tiktok-item { background: rgba(127,0,255,0.15); }
    .item.twitch-item { background: rgba(128,0,255,0.2); }
    .item.youtube-item { background: rgba(255,0,0,0.15); }
    .avatar { width:36px; height:36px; border-radius:50%; margin-right:0.5em; }
    .username { flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; margin-right:0.5em; }
    .details { text-align:right; font-size:0.9em; white-space:nowrap; }
/* make TikTok gift pics small again */
.details img.icon {
  width: 24px;
  height: 24px;
  margin-right: 0.5em;
}
/* full-screen white flash */
#bladeFlashOverlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: white;
  opacity: 0;
  pointer-events: none;
  z-index: 9999;
}

/* three quick scale-pulses */
@keyframes pulseScale {
  0%, 100% { transform: scale(1); }
  50%      { transform: scale(1.05); }
}

/* single white "blade pull" flash */
@keyframes bladeFlashAnim {
  0%   { opacity: 1; }
  20%  { opacity: 0.6; }
  100% { opacity: 0; }
}

.flashPulse {
  /* position:relative so the pseudo-flash is confined here */
  position: relative;
  animation: pulseScale 0.333s ease-in-out 0s 3 both;
}

/* use a pseudo-element to flash just this item */
.flashPulse::before {
  content: "";
  position: absolute;
  inset: 0;
  background: white;
  pointer-events: none;
  opacity: 0;
  animation: bladeFlashAnim 1s ease-in-out 0s 1 both;
}

  </style>
</head>
<body>
  <div class="stats-wrapper">
    <div class="platform-row">
      <div class="platform-icon-container">
        <div class="connection-status status-disconnected" id="tiktok-status"></div>
        <img class="platform-icon-inline" src="https://www.tiktok.com/favicon.ico" alt="TikTok" />
      </div>
      <div class="stat"><label>Viewers:</label><span id="tiktokViewers">0</span></div>
      <div class="stat"><label>Follows:</label><span id="tiktokFollows">0</span></div>
      <div class="stat"><label>Subs:</label><span id="tiktokSubs">0</span></div>
      <div class="stat"><label>Diamonds:</label><span id="tiktokDiamonds">0</span></div>
      <div class="stat"><label>Likes:</label><span id="tiktokLikes">0</span></div>
    </div>
    <div class="platform-row">
      <div class="platform-icon-container">
        <div class="connection-status status-disconnected" id="twitch-status"></div>
        <img class="platform-icon-inline" src="https://www.twitch.tv/favicon.ico" alt="Twitch" />
      </div>
      <div class="stat"><label>Viewers:</label><span id="twitchViewers">0</span></div>
      <div class="stat"><label>Follows:</label><span id="twitchFollows">0</span></div>
      <div class="stat"><label>Subs:</label><span id="twitchSubs">0</span></div>
      <div class="stat"><label>Bits:</label><span id="twitchBits">0</span></div>
      <div class="stat"><label>Raids:</label><span id="twitchRaids">0</span></div>
    </div>
    <div class="platform-row">
      <div class="platform-icon-container">
        <div class="connection-status status-disconnected" id="youtube-status"></div>
        <img class="platform-icon-inline" src="https://www.youtube.com/favicon.ico" alt="YouTube" />
      </div>
      <div class="stat"><label>Viewers:</label><span id="ytViewers">–</span></div>
      <div class="stat"><label>Subscribers:</label><span id="ytSubscribers">–</span></div>
      <div class="stat"><label>Members:</label><span id="ytMembers">0</span></div>
      <div class="stat"><label>SuperChats:</label><span id="ytSuperchats">0</span></div>
      <div class="stat polling">
        <button id="ytPollBtn">Start YouTube</button>
        <button id="ytStopBtn">Stop YouTube</button>
      </div>
    </div>
  </div>
  <div class="feed-header">Stream Events</div>
  <div class="feed"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script>
(async () => {
  const CONFIG = await window.electron.ipcRenderer.invoke('load-config');

  console.log('▶ Overlay loaded', CONFIG);
  
  // Connection status tracking
  const connectionStatus = {
    tiktok: false,
    twitch: false,
    youtube: false
  };
  
  // Function to update connection status indicators
  function updateConnectionStatus(service, isConnected) {
    connectionStatus[service] = isConnected;
    const statusElement = document.getElementById(`${service}-status`);
    if (statusElement) {
      if (isConnected) {
        statusElement.classList.remove('status-disconnected');
        statusElement.classList.add('status-connected');
        console.log(`▶ ${service.toUpperCase()} connected`);
      } else {
        statusElement.classList.remove('status-connected');
        statusElement.classList.add('status-disconnected');
        console.log(`▶ ${service.toUpperCase()} disconnected`);
      }
    }
  }

  // Immediately check Twitch status on page load
  (function checkTwitchStatus() {
    if (CONFIG.TWITCH_CLIENT_ID && (CONFIG.TWITCH_OAUTH || CONFIG.TWITCH_APP_TOKEN)) {
      // Call fetchTwitchStatus immediately
      fetchTwitchStatus();
    }
  })();

  // — fetch the live chat ID for the current stream —
  let ytLiveChatId = null;
  const ytSuperchatRevenue = {};  // store micros per currency

  (function initLiveChatId() {
    fetch(
      `https://www.googleapis.com/youtube/v3/liveBroadcasts?part=snippet&id=${CONFIG.YT_STREAM_ID}&key=${CONFIG.YT_API_KEY}`
    )
    .then(r=>r.json())
    .then(d=>{
      if (d.items?.length) {
        ytLiveChatId = d.items[0].snippet.liveChatId;
        // If we got a live chat ID, YouTube is connected
        updateConnectionStatus('youtube', true);
      }
    })
    .catch(error => {
      console.error('YouTube API error:', error);
      updateConnectionStatus('youtube', false);
    });
  })();


  function addItem({avatar,name,html,provider}) {
    const $it = $(`
      <div class="item ${provider}-item">
        <img class="avatar" src="${avatar}" alt="">
        <div class="username">${name}</div>
        <div class="details">${html}</div>
      </div>
    `);
    $('.feed')
      .append($it)
      .each(function() { this.scrollTop = this.scrollHeight; });

    $it.addClass('flashPulse');
    setTimeout(() => {
      $it.removeClass('flashPulse');
    }, 1000);
  }


  // Stats fetch
  const twCid = CONFIG.TW_SE_CID;
  const twToken = CONFIG.TW_SE_JWT;
  const ytCid = CONFIG.YT_SE_CID;
  const ytToken = CONFIG.YT_SE_JWT;
  let ytStatsInterval;

  document.getElementById('ytPollBtn').addEventListener('click', () => {
    if (ytStatsInterval) return;  // only start once
    console.log('▶ Overlay YT polling started');
    fetchStats();
    ytStatsInterval = setInterval(fetchStats, 60000);
    updateConnectionStatus('youtube', true);
  });
  
  document.getElementById('ytStopBtn').addEventListener('click', () => {
    if (!ytStatsInterval) return;
    clearInterval(ytStatsInterval);
    ytStatsInterval = null;
    console.log('▶ Overlay YT polling stopped');
    updateConnectionStatus('youtube', false);
  });

  const lastGiftStats = {};

  // Function to check Twitch status independently
  async function fetchTwitchStatus() {
    try {
      // Make sure we have valid credentials before making the API call
      if(!CONFIG.TWITCH_CLIENT_ID) {
        console.error('Missing Twitch Client ID');
        updateConnectionStatus('twitch', false);
        return;
      }
      
      // Check for token and log what we have
      if(!CONFIG.TWITCH_OAUTH && !CONFIG.TWITCH_APP_TOKEN) {
        console.error('Missing both TWITCH_OAUTH and TWITCH_APP_TOKEN');
        updateConnectionStatus('twitch', false);
        return;
      }
      
      // Prefer TWITCH_OAUTH over TWITCH_APP_TOKEN if available
      let token = CONFIG.TWITCH_OAUTH || CONFIG.TWITCH_APP_TOKEN;
      
      // Clean the token - remove oauth: prefix if present
      token = token.replace(/^oauth:/, '');
      
      console.log(`Checking Twitch connection with token starting with: ${token.substring(0, 5)}...`);
      
      const response = await fetch(
        `https://api.twitch.tv/helix/users?login=${CONFIG.TWITCH_CHANNEL}`,
        {
          headers: {
            'Client-ID': CONFIG.TWITCH_CLIENT_ID,
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        console.error(`Twitch API error: ${response.status} ${response.statusText}`);
        updateConnectionStatus('twitch', false);
        return;
      }
      
      // If we got here, the API call was successful
      updateConnectionStatus('twitch', true);
      
    } catch(e) {
      console.error('Twitch API check error', e);
      updateConnectionStatus('twitch', false);
    }
  }

  async function fetchStats(){
    if(twCid && twToken){
      try {
        // Make sure we have valid credentials before making the API call
        if(!CONFIG.TWITCH_CLIENT_ID) {
          console.error('Missing Twitch Client ID');
          $('#twitchViewers').text('0');
          updateConnectionStatus('twitch', false);
          throw new Error('Missing Twitch Client ID');
        }
        
        // Check for token and log what we have
        if(!CONFIG.TWITCH_OAUTH && !CONFIG.TWITCH_APP_TOKEN) {
          console.error('Missing both TWITCH_OAUTH and TWITCH_APP_TOKEN');
          $('#twitchViewers').text('0');
          updateConnectionStatus('twitch', false);
          throw new Error('Missing Twitch token');
        }
        
        // Prefer TWITCH_OAUTH over TWITCH_APP_TOKEN if available
        let token = CONFIG.TWITCH_OAUTH || CONFIG.TWITCH_APP_TOKEN;
        
        // Clean the token - remove oauth: prefix if present
        token = token.replace(/^oauth:/, '');
        
        console.log(`Fetching Twitch stream info with token starting with: ${token.substring(0, 5)}...`);
        
        const response = await fetch(
          `https://api.twitch.tv/helix/streams?user_login=${CONFIG.TWITCH_CHANNEL}`,
          {
            headers: {
              'Client-ID': CONFIG.TWITCH_CLIENT_ID,
              'Authorization': `Bearer ${token}`
            }
          }
        );
        
        if (!response.ok) {
          console.error(`Twitch API error: ${response.status} ${response.statusText}`);
          console.error(`Headers used: Client-ID: ${CONFIG.TWITCH_CLIENT_ID.substring(0, 5)}..., Token: ${token.substring(0, 5)}...`);
          $('#twitchViewers').text('API Error');
          updateConnectionStatus('twitch', false);
          throw new Error(`Twitch API request failed with status ${response.status}`);
        }
        
        // If we got here, the API call was successful
        updateConnectionStatus('twitch', true);
        
        const helix = await response.json();
        const viewers = helix.data[0]?.viewer_count || 0;
        $('#twitchViewers').text(viewers);
      } catch(e) {
        console.error('Twitch Helix error', e);
        updateConnectionStatus('twitch', false);
      }
    } else {
      updateConnectionStatus('twitch', false);
    }
    
    if(ytCid && ytToken){
      try {
        const yt = await fetch(
          `https://www.googleapis.com/youtube/v3/videos?part=liveStreamingDetails&id=${CONFIG.YT_STREAM_ID}&key=${CONFIG.YT_API_KEY}`
        ).then(r => r.json());
        const live = yt.items?.[0]?.liveStreamingDetails;
        const viewers = live?.concurrentViewers || 0;
        $('#ytViewers').text(viewers);
        updateConnectionStatus('youtube', true);
      } catch(e) {
        console.error('YouTube Data API error', e);
        updateConnectionStatus('youtube', false);
      }
    } else {
      updateConnectionStatus('youtube', false);
    }
  }

  // TikTok WS (Tikfinity)
  try {
    const tkWs = new WebSocket('ws://localhost:21213/');
    let tF = 0, tD = 0, tS = 0;
    const giftTimers  = {};
    const giftMaxEvents = {};
    
    // Track TikTok connection status
    tkWs.onopen = () => {
      updateConnectionStatus('tiktok', true);
      console.log('▶ TikTok WebSocket connected');
    };
    
    tkWs.onclose = () => {
      updateConnectionStatus('tiktok', false);
      console.log('▶ TikTok WebSocket disconnected');
    };
    
    tkWs.onerror = (error) => {
      updateConnectionStatus('tiktok', false);
      console.error('▶ TikTok WebSocket error:', error);
    };

    tkWs.onmessage = e => {
      const m = JSON.parse(e.data);
      console.log('▶ TikTok raw event:', m);
      const d = m.data;
      if (m.event === 'roomUser') {
        $('#tiktokViewers').text(d.viewerCount);
      } else if (m.event === 'like') {
        $('#tiktokLikes').text(d.totalLikeCount);
      } else if (m.event === 'follow') {
        tF++; $('#tiktokFollows').text(tF);
        addItem({ avatar: d.profilePictureUrl, name: d.uniqueId, html: 'FOLLOWED', provider: 'tiktok' });
      } else if (m.event === 'subscribe' || m.event === 'subscription') {
        const isReceiverOnlyGift = !d.giftType && d.receiverUniqueId;
        if ((d.giftType === 1 && d.senderUniqueId) || isReceiverOnlyGift) {
          const recv = d.receiverUniqueId || d.uniqueId;
          const from  = d.senderUniqueId || '(unknown sender)';
          addItem({ avatar: d.senderProfilePictureUrl || d.profilePictureUrl, name: from, html: `GIFT SUB from ${from} → ${recv}`, provider: 'tiktok' });
        } else {
          addItem({ avatar: d.profilePictureUrl, name: d.uniqueId, html: 'NEW SUB', provider: 'tiktok' });
        }
        tS++; $('#tiktokSubs').text(tS);
      } else if (m.event === 'gift') {
        // Only process stacked gifts at the end, like chat.html
        if (d.giftType === 1 && !d.repeatEnd) return;
        const key = d.groupId;
        if (!giftMaxEvents[key] || d.repeatCount > giftMaxEvents[key].repeatCount) giftMaxEvents[key] = d;
        if (giftTimers[key]) clearTimeout(giftTimers[key]);
        giftTimers[key] = setTimeout(() => {
          const gd = giftMaxEvents[key];
          const count = gd.repeatCount || 1;
          const totalDiamonds = (gd.diamondCount || 0) * count;
          tD += totalDiamonds; $('#tiktokDiamonds').text(tD);
          const icon = gd.giftPictureUrl || gd.giftImageUrl || '';
          addItem({ avatar: gd.profilePictureUrl, name: gd.uniqueId, html: (icon ? `<img class="icon" src="${icon}">` : '') + `${count}× ${gd.giftName}<br>${totalDiamonds} diamonds`, provider: 'tiktok' });
          delete giftMaxEvents[key]; delete giftTimers[key];
        }, 1000);
      }
    };
  } catch(err) { 
    console.error('TikTok WS error', err);
    updateConnectionStatus('tiktok', false);
  }

  // StreamElements Astro WS (Twitch & YouTube)
  try {
    const astro = new WebSocket('wss://astro.streamelements.com');
    let giftQueue = null;
    let twitchSubscribed = false;
    let youtubeSubscribed = false;
    
    astro.onopen = () => {
      console.log('▶ StreamElements Astro WS connected');
      
      // Send subscription requests for Twitch and YouTube
      if (twCid && twToken) {
        astro.send(JSON.stringify({type:'subscribe',data:{topic:'channel.activities',room:twCid,token:twToken,token_type:'jwt'}}));
      } else {
        console.log('▶ Twitch credentials missing, not subscribing to Twitch events');
      }
      
      if (ytCid && ytToken) {
        astro.send(JSON.stringify({type:'subscribe',data:{topic:'channel.activities',room:ytCid,token:ytToken,token_type:'jwt'}}));
      } else {
        console.log('▶ YouTube credentials missing, not subscribing to YouTube events');
      }
    };
    
    astro.onclose = () => {
      console.log('▶ StreamElements Astro WS closed');
      if (twitchSubscribed) updateConnectionStatus('twitch', false);
      if (youtubeSubscribed) updateConnectionStatus('youtube', false);
      twitchSubscribed = false;
      youtubeSubscribed = false;
    };
    
    astro.onerror = (error) => {
      console.error('▶ StreamElements Astro WS error:', error);
      if (twitchSubscribed) updateConnectionStatus('twitch', false);
      if (youtubeSubscribed) updateConnectionStatus('youtube', false);
    };
    
    astro.onmessage = e => {
      const m = JSON.parse(e.data);
      console.log('▶ Astro raw event:', m);
      
      // Check for subscription confirmations
      if (m.type === 'reply' && m.data?.topic === 'channel.activities') {
        if (m.data?.room === twCid) {
          twitchSubscribed = true;
          updateConnectionStatus('twitch', true);
          console.log('▶ Twitch events subscription confirmed');
        } else if (m.data?.room === ytCid) {
          youtubeSubscribed = true;
          updateConnectionStatus('youtube', true);
          console.log('▶ YouTube events subscription confirmed');
        }
        return;
      }
      
      if (m.type !== 'message' || m.topic !== 'channel.activities') return;
      
      const {provider, type, data:p} = m.data;
      
      if (provider === 'twitch') {
        console.log('▶ Twitch event:', type, p);
        if (type === 'follow') {
          addItem({avatar:p.avatar, name:p.displayName||p.username, html:'FOLLOWED', provider});
          $('#twitchFollows').text((+$('#twitchFollows').text()||0)+1);
        } else if (type === 'channelPointsRedemption' || type === 'redemption') {
          console.log('▶ redemption payload:', p);
          const user = p.displayName||p.username||p.userName||'Unknown';
          let reward = p.redemption?.reward?.title || p.reward?.title || p.reward?.name || p.rewardTitle || p.rewardName || p.title;
          if (!reward && p.amount) {
            reward = `${p.amount} Channel Points`;
          }
          console.log('▶ Channel point redemption:', user, reward);
          addItem({avatar:p.avatar, name:user, html:`REDEEMED: ${reward}`, provider});
        } else if (type === 'hypetrainStart') {
          addItem({avatar:'', name:'HYPE TRAIN', html:`Level ${p.level} Started`, provider});
        } else if (type === 'hypetrainProgress') {
          addItem({avatar:'', name:'HYPE TRAIN', html:`Progress: ${p.progress}/${p.goal}`, provider});
        } else if (type === 'hypetrainEnd') {
          addItem({avatar:'', name:'HYPE TRAIN', html:`Ended at Level ${p.level}`, provider});
        } else if (type === 'communityGiftPurchase') {
          giftQueue = {gifter:p.displayName||p.username, avatar:p.avatar, remaining:p.amount};
        } else if (type === 'subscription' || type === 'subscriber') {
          if (giftQueue && giftQueue.remaining > 0) {
            const recv = p.displayName||p.username;
            addItem({avatar:giftQueue.avatar, name:giftQueue.gifter, html:`GIFTED SUB to ${recv}`, provider});
            giftQueue.remaining--; 
            if (giftQueue.remaining === 0) giftQueue = null;
          } else {
            addItem({avatar:p.avatar, name:p.displayName||p.username, html:'SUBSCRIBED', provider});
          }
          $('#twitchSubs').text((+$('#twitchSubs').text()||0)+1);
        } else if (/tip|cheer/.test(type)) {
          addItem({avatar:p.avatar, name:p.displayName||p.username, html:`${p.bits||p.amount} bits`, provider});
          $('#twitchBits').text((+$('#twitchBits').text()||0)+(p.bits||p.amount));
        } else if (type === 'raid') {
          addItem({avatar:p.avatar, name:p.displayName||p.username, html:`RAID: ${p.amount}`, provider});
          $('#twitchRaids').text((+$('#twitchRaids').text()||0)+1);
        }
      } else if (provider === 'youtube') {
        console.log('▶ YouTube event:', type, p);
        if (type === 'subscriber') {
          addItem({avatar:p.avatar, name:p.displayName||p.username, html:'SUBSCRIBED', provider});
          $('#ytSubscribers').text((+$('#ytSubscribers').text()||0)+1);
        } else if (type === 'superchat') {
          addItem({avatar:p.avatar, name:p.displayName||p.username, html:`SUPERCHAT: ${p.amount}`, provider});
          $('#ytSuperchats').text((+$('#ytSuperchats').text()||0)+1);
        } else if (type === 'sponsor') {
          if (p.gifted) {
            addItem({avatar:p.avatar, name:p.sender, html:`GIFTED MEMBERSHIP to ${p.displayName||p.username}`, provider});
          } else {
            addItem({avatar:p.avatar, name:p.displayName||p.username, html:'NEW MEMBER', provider});
          }
          $('#ytMembers').text((+$('#ytMembers').text()||0)+1);
        }
      }
    };
  } catch(err) { 
    console.error('Astro init failed:', err);
    updateConnectionStatus('twitch', false);
    updateConnectionStatus('youtube', false);
  }
})();
  </script>
</body>
</html>
