<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HoellStream - Chat</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; padding:0; background:#000; color:#fff; font-family:sans-serif; }
    .chat-feed { height:100vh; overflow-y:auto; padding:10px; box-sizing:border-box; font-size:25px; }
    .chat-line { display:flex; align-items:center; margin-bottom:16px; }
    .platform-icon, .avatar { width:28px; height:28px; border-radius:50%; flex-shrink:0; }
    .avatar { margin-right:10px; }
    .username { font-weight:bold; color:#c47cff; margin-right:8px; }
    .message { flex:1; color:#fff; word-break:break-word; }
    .gift-icon, .emote { vertical-align:middle; margin:0 2px; max-height:28px; }
    
    /* Connection status indicators */
    .status-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: flex-start;
      background: rgba(0,0,0,0.8);
      padding: 5px;
      z-index: 100;
    }
    
    .platform-indicator {
      position: relative;
      margin-right: 15px;
      display: flex;
      align-items: center;
    }
    
    .platform-icon-container {
      position: relative;
      width: 28px;
      height: 28px;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-right: 8px;
    }
    
    .platform-icon {
      z-index: 2;
    }
    
    .connection-status {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      z-index: 1;
      transition: background-color 0.3s ease;
    }
    
    .status-connected {
      background-color: rgba(0, 255, 0, 0.3);
      box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
    }
    
    .status-disconnected {
      background-color: rgba(255, 0, 0, 0.3);
      box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
    }
    
    #ytToggleBtn,
    #ytStopBtn {
      font-family: sans-serif;
      font-size: 0.9em;
      font-weight: bold;
      color: #B266FF;
      background: rgba(50, 50, 50, 0.8);
      border: 1px solid #B266FF;
      border-radius: 4px;
      padding: 0.5em 1em;
      margin: 0.1em;
      cursor: pointer;
      white-space: nowrap;
      z-index: 200;
    }
    
    #ytToggleBtn:hover,
    #ytStopBtn:hover {
      background: rgba(80, 0, 160, 0.3);
    }
    
    #ytToggleBtn { position: absolute; top: 10px; right: 10px; }
    #ytStopBtn   { position: absolute; top: 40px; right: 10px; }
    
    /* Add padding to the top of chat feed to account for status bar */
    .chat-feed {
      padding-top: 40px;
    }
  </style>
</head>
<body>
  <!-- Status bar for connection indicators -->
  <div class="status-bar">
    <div class="platform-indicator">
      <div class="platform-icon-container">
        <div class="connection-status status-disconnected" id="tiktok-status"></div>
        <img class="platform-icon" src="https://www.tiktok.com/favicon.ico" alt="TikTok">
      </div>
    </div>
    <div class="platform-indicator">
      <div class="platform-icon-container">
        <div class="connection-status status-disconnected" id="twitch-status"></div>
        <img class="platform-icon" src="https://static.twitchcdn.net/assets/favicon-32-e29e246c157142c94346.png" alt="Twitch">
      </div>
    </div>
    <div class="platform-indicator">
      <div class="platform-icon-container">
        <div class="connection-status status-disconnected" id="youtube-status"></div>
        <img class="platform-icon" src="https://www.youtube.com/favicon.ico" alt="YouTube">
      </div>
    </div>
  </div>

  <div id="chatFeed" class="chat-feed"></div>
  <button id="ytToggleBtn">
    Start YouTube
  </button>
  <button id="ytStopBtn">
    Stop YouTube
  </button>
  <script>
(async () => {
  const C = await window.electron.ipcRenderer.invoke('load-config');

  console.log('▶ Unified Chat script loaded', C);
  const feed = document.getElementById('chatFeed');
  const icons = {
    tiktok: 'https://www.tiktok.com/favicon.ico',
    twitch: 'https://static.twitchcdn.net/assets/favicon-32-e29e246c157142c94346.png',
    youtube: 'https://www.youtube.com/favicon.ico'
  };
  
  // Connection status tracking
  const connectionStatus = {
    tiktok: false,
    twitch: false,
    youtube: false
  };
  
  // Function to update connection status indicators
  function updateConnectionStatus(service, isConnected) {
    connectionStatus[service] = isConnected;
    const statusElement = document.getElementById(`${service}-status`);
    if (statusElement) {
      if (isConnected) {
        statusElement.classList.remove('status-disconnected');
        statusElement.classList.add('status-connected');
        console.log(`▶ ${service.toUpperCase()} connected`);
      } else {
        statusElement.classList.remove('status-connected');
        statusElement.classList.add('status-disconnected');
        console.log(`▶ ${service.toUpperCase()} disconnected`);
      }
    }
  }

  // Cache for avatars
  const cache = {};
  
  // Emote handling
  const emotes = {};
  
  // Add a chat message to the feed
  function addChat(platform, user, message, avatar, color) {
    const line = document.createElement('div');
    line.className = 'chat-line';
    
    // Platform icon with status indicator
    const platformIconContainer = document.createElement('div');
    platformIconContainer.className = 'platform-icon-container';
    
    const platformIcon = document.createElement('img');
    platformIcon.className = 'platform-icon';
    platformIcon.src = icons[platform];
    platformIcon.alt = platform;
    
    platformIconContainer.appendChild(platformIcon);
    line.appendChild(platformIconContainer);
    
    // User avatar
    const avatarImg = document.createElement('img');
    avatarImg.className = 'avatar';
    avatarImg.src = avatar;
    avatarImg.alt = user;
    line.appendChild(avatarImg);
    
    // Username
    const username = document.createElement('div');
    username.className = 'username';
    username.textContent = user;
    if (color) username.style.color = color;
    line.appendChild(username);
    
    // Message content
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message';
    
    // Render TikTok gifts as HTML, others as text
    if (platform === 'tiktok' && /gift-icon/.test(message)) {
      messageDiv.innerHTML = message;
    } else if (platform === 'twitch' && emotes[user] && emotes[user][message]) {
      messageDiv.innerHTML = emotes[user][message];
    } else {
      messageDiv.textContent = message;
    }
    
    line.appendChild(messageDiv);
    feed.appendChild(line);
    feed.scrollTop = feed.scrollHeight;
  }

  function getAvatar(user) {
    if(cache[user]) return Promise.resolve(cache[user]);
    
    // Make sure we have valid credentials before making the API call
    if(!C.TWITCH_CLIENT_ID) {
      console.error('Missing Twitch Client ID');
      return Promise.resolve(icons.twitch);
    }
    
    // Check for token and log what we have
    if(!C.TWITCH_OAUTH && !C.TWITCH_APP_TOKEN) {
      console.error('Missing both TWITCH_OAUTH and TWITCH_APP_TOKEN');
      return Promise.resolve(icons.twitch);
    }
    
    // Prefer TWITCH_OAUTH over TWITCH_APP_TOKEN if available
    let token = C.TWITCH_OAUTH || C.TWITCH_APP_TOKEN;
    
    // Clean the token - remove oauth: prefix if present
    token = token.replace(/^oauth:/, '');
    
    console.log(`Fetching avatar for ${user} with token starting with: ${token.substring(0, 5)}...`);
    
    return fetch(`https://api.twitch.tv/helix/users?login=${user}`, {
      headers: { 
        'Client-ID': C.TWITCH_CLIENT_ID, 
        'Authorization': `Bearer ${token}` 
      }
    }).then(r => {
      if (!r.ok) {
        console.error(`Twitch API error: ${r.status} ${r.statusText}`);
        console.error(`Headers used: Client-ID: ${C.TWITCH_CLIENT_ID.substring(0, 5)}..., Token: ${token.substring(0, 5)}...`);
        throw new Error(`API request failed with status ${r.status}`);
      }
      return r.json();
    }).then(j => {
      const url = j.data?.[0]?.profile_image_url || icons.twitch;
      cache[user] = url; return url;
    }).catch(err => {
      console.error('Error fetching Twitch avatar:', err);
      return icons.twitch;
    });
  }
  
  // Twitch Chat WebSocket
  const tw = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
  
  tw.onopen = () => {
    console.log('Twitch IRC open');
    // use the token exactly as given (it already has "oauth:")
    tw.send(`PASS ${C.TWITCH_OAUTH}`);
    tw.send(`NICK ${C.TWITCH_CHANNEL}`);
    tw.send(`JOIN #${C.TWITCH_CHANNEL}`);
    updateConnectionStatus('twitch', true);
  };
  
  tw.onclose = () => {
    console.log('Twitch IRC closed');
    updateConnectionStatus('twitch', false);
  };
  
  tw.onerror = (error) => {
    console.error('Twitch IRC error:', error);
    updateConnectionStatus('twitch', false);
  };

  // Cache for display names
  const displayNameCache = {};
  
  // Function to extract display name from IRC tags
  function extractDisplayName(tags, username) {
    if (!tags) return displayNameCache[username] || username;
    
    // Log the tags for debugging
    console.log('▶ Twitch tags:', tags);
    
    // Extract display-name from tags
    // Tags format is like: display-name=UserName;emotes=;subscriber=0;...
    const displayNameMatch = tags.match(/display-name=([^;]+)/i);
    if (displayNameMatch && displayNameMatch[1] && displayNameMatch[1] !== '') {
      console.log('▶ Found display name:', displayNameMatch[1]);
      return displayNameMatch[1];
    }
    
    // If no display name in tags or it's empty, use the username
    return displayNameCache[username] || username;
  }

  tw.onmessage = e => {
    const msg = e.data.trim();
    console.log('▶ Twitch raw:', msg);
    
    if (msg.includes('PING :tmi.twitch.tv')) {
      tw.send('PONG :tmi.twitch.tv');
      return;
    }
    
    if (msg.includes('PRIVMSG')) {
      try {
        // Parse the message properly for IRCv3 tags
        let tags = {};
        let username = '';
        let text = '';
        
        // Check if message has tags (starts with @)
        if (msg.startsWith('@')) {
          const tagPart = msg.substring(1, msg.indexOf(' '));
          // Parse tags into an object
          tagPart.split(';').forEach(tag => {
            const [key, value] = tag.split('=');
            if (key && value !== undefined) {
              tags[key] = value;
            }
          });
          
          // Extract username and message text
          const restOfMessage = msg.substring(msg.indexOf(' ') + 1);
          const userMatch = restOfMessage.match(/:([^!]+).*PRIVMSG #[^ ]+ :(.*)/); 
          if (userMatch) {
            username = userMatch[1];
            text = userMatch[2];
          }
        } else {
          // Fallback for messages without tags
          const match = msg.match(/:([^!]+).*PRIVMSG #[^ ]+ :(.*)/); 
          if (match) {
            username = match[1];
            text = match[2];
          }
        }
        
        if (username && text) {
          // Get display name from tags or use username
          let displayName = username;
          
          if (tags && tags['display-name']) {
            displayName = tags['display-name'];
            console.log(`▶ Using display name from tags: ${displayName}`);
          } else if (displayNameCache[username]) {
            displayName = displayNameCache[username];
            console.log(`▶ Using cached display name: ${displayName}`);
          }
          
          console.log(`▶ Twitch message from ${username}, display name: ${displayName}`);
          
          // Cache the display name for future messages
          displayNameCache[username] = displayName;
          
          getAvatar(username).then(avatar => {
            addChat('twitch', displayName, text, avatar);
          });
        }
      } catch (error) {
        console.error('Error parsing Twitch message:', error, msg);
      }
    }
  };
  
  // TikTok WebSocket
  try {
    const tikWs = new WebSocket('ws://localhost:21213/');
    
    tikWs.onopen = () => {
      console.log('▶ TikTok WebSocket connected');
      updateConnectionStatus('tiktok', true);
    };
    
    tikWs.onclose = () => {
      console.log('▶ TikTok WebSocket closed');
      updateConnectionStatus('tiktok', false);
    };
    
    tikWs.onerror = (error) => {
      console.error('▶ TikTok WebSocket error:', error);
      updateConnectionStatus('tiktok', false);
    };
    
    tikWs.onmessage = e => {
      const m = JSON.parse(e.data);
      console.log('▶ TikTok raw event:', m);
      
      if (m.event === 'chat') {
        const d = m.data;
        const avatar = d.profilePictureUrl || icons.tiktok;
        const displayName = d.nickname || d.uniqueId || 'Unknown';
        addChat('tiktok', displayName, d.comment, avatar);
      } else if (m.event === 'gift') {
        const d = m.data;
        // Only show after stacking is complete
        if (d.giftType === 1 && !d.repeatEnd) return;
        const avatar = d.profilePictureUrl || icons.tiktok;
        const displayName = d.nickname || d.uniqueId || 'Unknown';
        const count = d.repeatCount || 1;
        const totalDiamonds = (d.diamondCount || 0) * count;
        const giftIcon = d.giftPictureUrl ? `<img class='gift-icon' src='${d.giftPictureUrl}' alt='gift'>` : '';
        // Format: USERNAME: sent AMOUNT× GIFT TITLE GIFT PICTURE (DIAMONDS)
        const giftMsg = `sent ${count}× ${d.giftName} ${giftIcon} <span style='font-size:0.85em;color:#FFD700;'>(${totalDiamonds} diamonds)</span>`;
        addChat('tiktok', displayName, giftMsg, avatar);
      }
    };
  } catch (err) {
    console.error('TikTok WS error', err);
    updateConnectionStatus('tiktok', false);
  }
  
  // YouTube Chat
  let ytChatInterval;
  let ytNextPageToken = null;
  
  document.getElementById('ytToggleBtn').addEventListener('click', () => {
    if (ytChatInterval) return; // already running
    console.log('▶ Starting YouTube chat polling');
    updateConnectionStatus('youtube', true);
    
    // Initial fetch
    fetchYouTubeChat();
    
    // Then poll every 5 seconds
    ytChatInterval = setInterval(fetchYouTubeChat, 5000);
  });
  
  document.getElementById('ytStopBtn').addEventListener('click', () => {
    if (!ytChatInterval) return;
    clearInterval(ytChatInterval);
    ytChatInterval = null;
    ytNextPageToken = null;
    console.log('▶ Stopped YouTube chat polling');
    updateConnectionStatus('youtube', false);
  });
  
  async function fetchYouTubeChat() {
    try {
      // First we need to get the live chat ID if we don't have it
      if (!C.YT_LIVE_CHAT_ID) {
        console.log('▶ YouTube: Fetching live chat ID for stream:', C.YT_STREAM_ID);
        
        if (!C.YT_STREAM_ID || !C.YT_API_KEY) {
          console.error('▶ YouTube: Missing stream ID or API key');
          updateConnectionStatus('youtube', false);
          return;
        }
        
        const videoResponse = await fetch(
          `https://www.googleapis.com/youtube/v3/videos?part=liveStreamingDetails&id=${C.YT_STREAM_ID}&key=${C.YT_API_KEY}`
        );
        
        if (!videoResponse.ok) {
          console.error('▶ YouTube API error:', videoResponse.status, videoResponse.statusText);
          updateConnectionStatus('youtube', false);
          return;
        }
        
        const videoData = await videoResponse.json();
        console.log('▶ YouTube video data:', videoData);
        
        if (!videoData.items || !videoData.items[0] || !videoData.items[0].liveStreamingDetails) {
          console.error('▶ YouTube: No live streaming details found');
          updateConnectionStatus('youtube', false);
          return;
        }
        
        C.YT_LIVE_CHAT_ID = videoData.items[0].liveStreamingDetails.activeLiveChatId;
        console.log('▶ YouTube: Got live chat ID:', C.YT_LIVE_CHAT_ID);
        
        if (!C.YT_LIVE_CHAT_ID) {
          console.error('▶ YouTube: No active live chat ID found');
          updateConnectionStatus('youtube', false);
          return;
        }
      }
      
      // Now fetch the chat messages
      const chatUrl = `https://www.googleapis.com/youtube/v3/liveChat/messages?liveChatId=${C.YT_LIVE_CHAT_ID}&part=snippet,authorDetails&maxResults=200${ytNextPageToken ? `&pageToken=${ytNextPageToken}` : ''}&key=${C.YT_API_KEY}`;
      
      const chatResponse = await fetch(chatUrl);
      const chatData = await chatResponse.json();
      
      if (chatData.error) {
        console.error('▶ YouTube chat error:', chatData.error);
        updateConnectionStatus('youtube', false);
        return;
      }
      
      // Store the next page token for subsequent requests
      ytNextPageToken = chatData.nextPageToken;
      
      // Process the chat messages
      for (const item of chatData.items || []) {
        const message = item.snippet.displayMessage;
        const user = item.authorDetails.displayName;
        const avatar = item.authorDetails.profileImageUrl || icons.youtube;
        
        addChat('youtube', user, message, avatar);
      }
      
      updateConnectionStatus('youtube', true);
    } catch (error) {
      console.error('▶ Error fetching YouTube chat:', error);
      updateConnectionStatus('youtube', false);
    }
  }
})();
  </script>
</body>
</html>
