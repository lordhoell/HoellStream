<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HoellStream - Chat</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; padding:0; background:#000; color:#fff; font-family:sans-serif; }
    .chat-feed { height:100vh; overflow-y:auto; padding:10px; box-sizing:border-box; font-size:25px; }
    .chat-line { display:flex; align-items:center; margin-bottom:16px; }
    .platform-icon, .avatar { width:28px; height:28px; border-radius:50%; flex-shrink:0; }
    .platform-icon { margin-right:12px; }
    .avatar { margin-right:10px; }
    .username { font-weight:bold; color:#c47cff; margin-right:8px; }
    .message { flex:1; color:#fff; word-break:break-word; }
    .gift-icon, .emote { vertical-align:middle; max-height:28px; }
    .gift-icon {
      height: 20px;
      margin: 0 4px;
    }
    
    .emote {
      height: 24px;
      margin: 0 2px;
      display: inline-block;
    }
    
    /* Twitch emote styling */
    .twitch-emote {
      height: 1.5em;
      vertical-align: middle;
      margin: 0 2px;
      display: inline-block;
    }
    
    /* YouTube emoji styling */
    .youtube-emoji {
      height: 36px;
      width: 36px;
      vertical-align: middle;
      margin: 0 2px;
      display: inline-block;
    }
    
    /* Connection status indicators */
    .status-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: flex-start;
      background: rgba(0,0,0,0.8);
      padding: 5px;
      z-index: 100;
    }
    
    .platform-indicator {
      position: relative;
      margin-right: 15px;
      display: flex;
      align-items: center;
    }
    
    .platform-icon-container {
      position: relative;
      width: 28px;
      height: 28px;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-right: 8px;
    }
    
    .platform-icon-status {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      flex-shrink: 0;
      z-index: 2;
      margin: 0;
    }
    
    .platform-icon {
      z-index: 2;
    }
    
    .connection-status {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      z-index: 1;
      transition: background-color 0.3s ease;
    }
    
    .status-connected {
      background-color: rgba(0, 255, 0, 0.3);
      box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
    }
    
    .status-disconnected {
      background-color: rgba(255, 0, 0, 0.3);
      box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
    }
    
    /* Add padding to the top of chat feed to account for status bar */
    .chat-feed {
      padding-top: 40px;
    }
    
    /* Badge styling */
    .badge {
      font-size: 20px;
      height: 24px;
      vertical-align: middle;
      margin-right: 4px;
    }
    .badge img {
      height: 24px;
      width: auto;
      vertical-align: middle;
      margin-right: 4px;
    }
    .mod-badge {
      color: #3498db;
    }
    .sub-badge {
      color: #e74c3c;
    }
    .badges {
      margin-left: 0;
    }
    .owner-badge {
      color: #ff69b4;
    }
    .member-badge {
      color: #f1c40f;
    }
    .vip-badge {
      color: #9b59b6;
    }
    .badge-default {
      /* Default styling for other badge types like bits, prime, etc. */
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <!-- Status bar for connection indicators -->
  <div class="status-bar">
    <div class="platform-indicator">
      <div class="platform-icon-container">
        <div class="connection-status status-disconnected" id="tiktok-status"></div>
        <img class="platform-icon-status" src="https://www.tiktok.com/favicon.ico" alt="TikTok">
      </div>
    </div>
    <div class="platform-indicator">
      <div class="platform-icon-container">
        <div class="connection-status status-disconnected" id="twitch-status"></div>
        <img class="platform-icon-status" src="https://static.twitchcdn.net/assets/favicon-32-e29e246c157142c94346.png" alt="Twitch">
      </div>
    </div>
    <div class="platform-indicator">
      <div class="platform-icon-container">
        <div class="connection-status status-disconnected" id="youtube-status"></div>
        <img class="platform-icon-status" src="https://www.youtube.com/favicon.ico" alt="YouTube">
      </div>
    </div>
  </div>

  <div id="chatFeed" class="chat-feed"></div>
  <script>
(async () => {
  // Load OAuth tokens only
  let TOKENS = await window.electron.ipcRenderer.invoke('get-tokens');
  
  // Load configuration for font sizes
  const CONFIG = await window.electron.ipcRenderer.invoke('load-config') || {};
  
  // Apply font sizes from config
  if (CONFIG.CHAT_FONT_SIZE) {
    document.querySelector('.chat-feed').style.fontSize = CONFIG.CHAT_FONT_SIZE + 'px';
  }
  
  // Apply username font size
  if (CONFIG.USERNAME_FONT_SIZE) {
    const style = document.createElement('style');
    style.id = 'dynamic-username-style';
    style.textContent = `.username { font-size: ${CONFIG.USERNAME_FONT_SIZE}em !important; }`;
    document.head.appendChild(style);
  }
  
  console.log('Chat script loaded with OAuth tokens');
  console.log('Twitch token available:', !!TOKENS?.twitch?.access_token);

  const feed = document.getElementById('chatFeed');
  const icons = {
    tiktok: 'https://www.tiktok.com/favicon.ico',
    twitch: 'https://static.twitchcdn.net/assets/favicon-32-e29e246c157142c94346.png',
    youtube: 'https://www.youtube.com/favicon.ico'
  };
  
  // Connection status tracking
  const connectionStatus = {
    tiktok: false,
    twitch: false,
    youtube: false
  };
  
  // Function to update connection status indicators
  function updateConnectionStatus(service, isConnected) {
    console.log(`updateConnectionStatus called with service: ${service}, isConnected: ${isConnected}`);
    connectionStatus[service] = isConnected;
    const statusElement = document.getElementById(`${service}-status`);
    if (statusElement) {
      if (isConnected) {
        statusElement.classList.remove('status-disconnected');
        statusElement.classList.add('status-connected');
        console.log(`‚ñ∂ ${service.toUpperCase()} connected`);
      } else {
        statusElement.classList.remove('status-connected');
        statusElement.classList.add('status-disconnected');
        console.log(`‚ñ∂ ${service.toUpperCase()} disconnected`);
      }
    }
  }

  // Cache for avatars
  const cache = {};
  
  // Emote handling
  const emotes = {};
  
  // Add a chat message to the feed
  function addChat(platform, user, message, avatar, color, isHtml = false, badges = null) {
    console.log(`[addChat] Called with:`, { platform, user, message, avatar, color, isHtml, badges });
    
    const line = document.createElement('div');
    line.className = 'chat-line';
    
    // Platform icon
    const platformIcon = document.createElement('img');
    platformIcon.className = 'platform-icon';
    platformIcon.src = icons[platform];
    platformIcon.alt = platform;
    line.appendChild(platformIcon);
    
    // User avatar
    const avatarImg = document.createElement('img');
    avatarImg.className = 'avatar';
    avatarImg.src = avatar || icons[platform];
    avatarImg.alt = user;
    line.appendChild(avatarImg);
    
    // Username with badges
    const username = document.createElement('div');
    username.className = 'username';
    username.textContent = user;
    if (color) username.style.color = color;
    
    // Add badges after username
    if (badges && badges.length > 0) {
      const badgeContainer = document.createElement('span');
      badgeContainer.className = 'badges';
      badgeContainer.innerHTML = ' ' + badges.join(' ');
      username.appendChild(badgeContainer);
    }
    
    line.appendChild(username);
    
    // Message content
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message';
    
    // Render messages with HTML or emotes
    if (isHtml || platform === 'tiktok' && /gift-icon/.test(message)) {
      messageDiv.innerHTML = message;
    } else if (platform === 'twitch' && emotes[user] && emotes[user][message]) {
      messageDiv.innerHTML = emotes[user][message];
    } else {
      messageDiv.textContent = message;
    }
    
    line.appendChild(messageDiv);
    feed.appendChild(line);
    feed.scrollTop = feed.scrollHeight;
    
    console.log(`[addChat] Successfully added message to feed. Total messages in feed: ${feed.children.length}`);
  }

  async function getAvatar(user) {
    if(cache[user]) return cache[user];
    
    try {
      
      // Use the auth module to ensure we have a valid token
      const hasToken = await window.electron.auth.ensureTwitchToken();
      if (!hasToken) {
        console.error('No valid Twitch token available');
        return icons.twitch;
      }
      
      // Refresh our tokens to ensure we have the latest
      TOKENS = await window.electron.ipcRenderer.invoke('get-tokens');
      if (!TOKENS?.twitch?.access_token) {
        console.error('No Twitch access token available');
        return icons.twitch;
      }
      
      console.log('Using refreshed token:', TOKENS.twitch.access_token.substring(0, 5) + '...');
      
      console.log(`Making API call to get avatar for user: ${user}`);
      
      // Get the Client-ID from the token validation
      const validateResponse = await fetch('https://id.twitch.tv/oauth2/validate', {
        headers: { 'Authorization': `OAuth ${TOKENS.twitch.access_token}` }
      });
      
      if (!validateResponse.ok) {
        console.error(`Token validation failed: ${validateResponse.status}`);
        return icons.twitch;
      }
      
      const validateData = await validateResponse.json();
      const clientId = validateData.client_id;
      
      console.log(`Using Client-ID from token: ${clientId}`);
      console.log(`Using token: ${TOKENS.twitch.access_token.substring(0, 5)}...`);
      
      // Make the API call to get user info
      const response = await fetch(`https://api.twitch.tv/helix/users?login=${user}`, {
        headers: {
          'Client-ID': clientId,
          'Authorization': `Bearer ${TOKENS.twitch.access_token}`
        }
      });
      
      if (!response.ok) {
        console.error(`Error fetching avatar for ${user}: ${response.status}`);
        console.error(`Response details:`, await response.text());
        return icons.twitch;
      }
      
      const data = await response.json();
      console.log(`Avatar data for ${user}:`, data);
      const url = data.data?.[0]?.profile_image_url || icons.twitch;
      cache[user] = url;
      return url;
    } catch (err) {
      console.error('Error fetching Twitch avatar:', err);
      return icons.twitch;
    }
  }
  
  // Function to extract TikTok badges from user data
  function extractTikTokBadges(data) {
    const badges = [];
    
    // Check for moderator badge
    if (data.isModerator) {
      badges.push('<span class="badge mod-badge" title="Moderator">üëÆ</span>');
    }
    
    // Check for subscriber badge
    if (data.isSubscriber) {
      // Try to get subscriber badge image from userBadges array
      let subBadgeFound = false;
      if (data.userBadges && Array.isArray(data.userBadges)) {
        for (const badge of data.userBadges) {
          if (badge.type === 'image' && badge.url && badge.url.includes('subs_badge')) {
            badges.push(`<img class="badge sub-badge" src="${badge.url}" title="Subscriber" alt="Sub">`);
            subBadgeFound = true;
            break;
          }
        }
      }
      // Fallback to emoji if no image badge found
      if (!subBadgeFound) {
        badges.push('<span class="badge sub-badge" title="Subscriber">‚≠ê</span>');
      }
    }
    
    return badges;
  }

  // Function to extract Twitch badges from user data
  function extractTwitchBadges(data) {
    const badges = [];
    
    // Check for broadcaster badge
    if (data.tags && data.tags.badges && data.tags.badges.includes('broadcaster')) {
      badges.push('<span class="badge broadcaster-badge" title="Broadcaster">üëë</span>');
    }
    
    // Check for moderator badge
    if (data.tags && data.tags.badges && data.tags.badges.includes('moderator')) {
      badges.push('<span class="badge mod-badge" title="Moderator">üó°Ô∏è</span>');
    }
    
    // Check for subscriber badge
    if (data.tags && data.tags.badges && data.tags.badges.includes('subscriber')) {
      badges.push('<span class="badge sub-badge" title="Subscriber">‚≠ê</span>');
    }
    
    // Check for VIP badge
    if (data.tags && data.tags.badges && data.tags.badges.includes('vip')) {
      badges.push('<span class="badge vip-badge" title="VIP">üíé</span>');
    }
    
    return badges;
  }

  // Function to extract YouTube badges from user data
  function extractYouTubeBadges(data) {
    const badges = [];
    
    // Check for channel owner badge (YouTube doesn't have owner badges)
    if (data.isChatOwner) {
      badges.push('<span class="badge owner-badge" title="Channel Owner">üëë</span>');
    }
    
    // Check for moderator badge
    if (data.isChatModerator) {
      // Try to get cached moderator badge image
      const moderatorBadgePath = getCachedBadgePath('moderator');
      if (moderatorBadgePath) {
        badges.push(`<img class="badge mod-badge" src="file://${moderatorBadgePath}" alt="Moderator" title="Moderator" />`);
      } else {
        // Fallback to emoji
        badges.push('<span class="badge mod-badge" title="Moderator">üîß</span>');
      }
    }
    
    // Check for member/sponsor badge
    if (data.isChatSponsor) {
      // Try to get cached member badge image
      const memberBadgePath = getCachedBadgePath('member');
      if (memberBadgePath) {
        badges.push(`<img class="badge member-badge" src="file://${memberBadgePath}" alt="Channel Member" title="Channel Member" />`);
      } else {
        // Fallback to emoji
        badges.push('<span class="badge member-badge" title="Channel Member">üíé</span>');
      }
    }
    
    return badges;
  }

  // Function to extract Twitch badges from user data
  function extractTwitchBadges(data) {
    const badges = [];
    const tags = data.tags || {};
    const badgeData = data.badgeData || [];
    
    console.log('[extractTwitchBadges] Processing tags:', tags);
    console.log('[extractTwitchBadges] Badge data:', badgeData);
    
    // If we have official badge data, use those images
    if (badgeData && badgeData.length > 0) {
      // Sort badges by importance (broadcaster > moderator > vip > subscriber)
      const badgeOrder = ['broadcaster', 'moderator', 'vip', 'subscriber', 'bits'];
      
      badgeData.sort((a, b) => {
        const aIndex = badgeOrder.indexOf(a.setId);
        const bIndex = badgeOrder.indexOf(b.setId);
        return (aIndex === -1 ? 999 : aIndex) - (bIndex === -1 ? 999 : bIndex);
      });
      
      badgeData.forEach(badge => {
        let badgeClass = 'badge';
        let shouldShowBadge = true;
        
        // Add specific styling classes - only for badges we want to show
        switch (badge.setId) {
          case 'broadcaster':
            badgeClass += ' owner-badge';
            break;
          case 'moderator':
            badgeClass += ' mod-badge';
            break;
          case 'vip':
            badgeClass += ' vip-badge';
            break;
          case 'subscriber':
            badgeClass += ' sub-badge';
            break;
          default:
            // Skip all other badges (like no-sound, bits, etc.)
            shouldShowBadge = false;
        }
        
        // Only add badge to display if it's one we want to show
        if (shouldShowBadge) {
          badges.push(`<img class="${badgeClass}" src="${badge.imageUrl}" alt="${badge.title}" title="${badge.description}" />`);
        }
      });
    } else {
      // Fallback to emoji badges if no official badge data
      const badgesTag = tags.badges || '';
      const badgesList = badgesTag.split(',').filter(b => b.trim());
      
      // Check individual boolean flags as backup
      const isMod = tags.mod === '1' || badgesList.some(b => b.startsWith('moderator/'));
      const isSub = tags.subscriber === '1' || badgesList.some(b => b.startsWith('subscriber/'));
      const isVip = badgesList.some(b => b.startsWith('vip/'));
      const isBroadcaster = badgesList.some(b => b.startsWith('broadcaster/'));
      
      // Add emoji badges in order of importance
      if (isBroadcaster) {
        badges.push('<span class="badge owner-badge">üëë</span>');
      }
      if (isMod) {
        badges.push('<span class="badge mod-badge">üîß</span>');
      }
      if (isVip) {
        badges.push('<span class="badge vip-badge">üíé</span>');
      }
      if (isSub) {
        badges.push('<span class="badge sub-badge">‚≠ê</span>');
      }
    }
    
    console.log('[extractTwitchBadges] Extracted badges:', badges);
    return badges;
  }

  // Function to get cached badge path (similar to emoji caching)
  function getCachedBadgePath(badgeType) {
    try {
      const { app } = require('electron').remote || require('@electron/remote');
      const path = require('path');
      const fs = require('fs');
      
      const badgeCacheDir = path.join(app.getPath('userData'), 'badge-cache');
      const badgePath = path.join(badgeCacheDir, `${badgeType}.png`);
      
      // Check if badge file exists
      if (fs.existsSync(badgePath)) {
        return badgePath;
      }
    } catch (error) {
      console.log(`[Badge Cache] Could not access cached badge ${badgeType}:`, error);
    }
    
    return null;
  }

  // Twitch Chat IPC listener
  window.electron.ipcRenderer.on('twitch-chat-message', (event, data) => {
    console.log('Received Twitch chat message:', data);
    const { username, message, tags } = data;
    const displayName = tags['display-name'] || username;
    getAvatar(username).then(avatar => {
      // Check if message contains HTML (emotes)
      const hasEmotes = message.includes('<img');
      addChat('twitch', displayName, message, avatar, null, hasEmotes, extractTwitchBadges(data));
    });
  });

  // YouTube Events IPC listener (for all events including chat)
  window.electron.ipcRenderer.on('youtube-data-update', (event, data) => {
    console.log('Received YouTube data update:', data);
    console.log('YouTube events array:', data?.events);
    console.log('Number of YouTube events:', data?.events?.length || 0);
    
    // Add detailed emoji debugging for YouTube chat messages
    if (data && data.chatMessages && data.chatMessages.length > 0) {
      console.log(`üîç [Chat] Processing ${data.chatMessages.length} YouTube chat messages`);
      data.chatMessages.forEach((msg, index) => {
        console.log(`üîç [Chat] YouTube message ${index}:`, {
          displayName: msg.displayName,
          message: msg.message,
          fullMessage: msg,
          hasHtml: msg.message && msg.message.includes('<'),
          messageLength: msg.message ? msg.message.length : 0
        });
      });
    }
    
    // Process all events (chat, superchats, memberships, etc.)
    if (data && data.events && data.events.length > 0) {
      data.events.forEach(event => {
        console.log(`üîç [Chat] Processing YouTube event:`, event);
        console.log(`üîç [Chat] Event type: ${event.type}`);
        console.log(`üîç [Chat] Raw event message field:`, event.message);
        console.log(`üîç [Chat] Raw event text field:`, event.text);
        console.log(`üîç [Chat] Event contains HTML:`, event.message && event.message.includes('<'));
        
        // Special logging for membership and jewel gift events
        if (event.type === 'sponsor' || event.type === 'gift_membership_purchase' || event.type === 'gift_membership_received') {
          console.log(`üéÅ [Chat] MEMBERSHIP EVENT DETECTED:`, event.type, event);
        }
        if (event.type === 'jewel_gift') {
          console.log(`üíé [Chat] JEWEL GIFT EVENT DETECTED:`, event.type, event);
        }
        
        // Map event data with proper avatar and display name fallbacks (like overlay does)
        const mappedEvent = {
          ...event,
          // Ensure avatar and displayName are available
          avatar: event.author?.avatar || event.avatar || icons.youtube,
          displayName: event.author?.name || event.displayName || event.username || 'Unknown User'
        };
        
        handleYouTubeEvent(event.type, mappedEvent);
      });
    }
    
    // Update connection status
    updateConnectionStatus('youtube', data.connectionStatus);
  });

  // Function to handle YouTube events and display them in chat format
  function handleYouTubeEvent(eventType, eventData) {
    console.log(`üîç [Chat] handleYouTubeEvent called with type: ${eventType}`, eventData);
    
    // Special logging for membership and jewel gift events
    if (eventType === 'sponsor' || eventType === 'gift_membership_purchase' || eventType === 'gift_membership_received') {
      console.log(`üéÅüéÅ [Chat] HANDLING MEMBERSHIP EVENT IN handleYouTubeEvent:`, eventType);
    }
    if (eventType === 'jewel_gift') {
      console.log(`üíéüíé [Chat] HANDLING JEWEL GIFT EVENT IN handleYouTubeEvent:`, eventType, eventData);
    }
    
    // Skip malformed events with undefined/empty content
    if (!eventType || eventType === 'undefined') {
      console.log(`‚ö†Ô∏è [Chat] Ignoring malformed YouTube event with undefined type`);
      return;
    }
    
    let message = '';
    const rawMessage = eventData.message || eventData.text || '';
    
    switch(eventType) {
      case 'chat':
      case 'textMessageEvent':
        // For chat messages, skip if empty
        if (!rawMessage || rawMessage === 'undefined') {
          console.log(`‚ö†Ô∏è [Chat] Ignoring YouTube chat event with undefined/empty message`);
          return;
        }
        // Regular chat message - check for emoji processing
        console.log(`üîç [Chat] Processing YouTube chat message: "${rawMessage}"`);
        console.log(`üîç [Chat] Message contains HTML: ${rawMessage.includes('<')}`);
        console.log(`üîç [Chat] Message contains img tags: ${rawMessage.includes('<img')}`);
        
        // Check if message already contains processed emojis (HTML img tags)
        if (rawMessage.includes('<img') && rawMessage.includes('youtube-emoji')) {
          console.log(`‚úÖ [Chat] Message already contains processed YouTube emojis!`);
          message = rawMessage; // Use as-is since it's already processed
        } else {
          console.log(`üìù [Chat] Using raw message text (no emojis detected)`);
          message = rawMessage;
        }
        break;
      case 'superchat':
      case 'superChatEvent':
        message = `Super Chat ${eventData.amount || ''} ${eventData.message || ''}`.trim();
        break;
      case 'supersticker':
      case 'superStickerEvent':
        message = `Super Sticker ${eventData.amount || ''}`;
        break;
      case 'sponsor':
      case 'newSponsorEvent':
        if (eventData.gifted) {
          if (eventData.giftCount) {
            message = `gifted ${eventData.giftCount} memberships`;
          } else {
            message = `gifted a membership`;
          }
          if (eventData.giftRecipient) {
            message += ` to ${eventData.giftRecipient}`;
          }
          if (eventData.memberLevelName) {
            message += ` (${eventData.memberLevelName})`;
          }
        } else {
          message = `just became a member!`;
          if (eventData.memberLevelName) {
            message = `just became a ${eventData.memberLevelName} member!`;
          }
          if (eventData.isUpgrade) {
            message = `upgraded their membership to ${eventData.memberLevelName || 'Member'}!`;
          }
        }
        break;
      case 'milestone':
      case 'memberMilestoneChatEvent':
        message = `membership milestone`;
        if (eventData.memberMonth) {
          message += ` (${eventData.memberMonth} months)`;
        }
        if (eventData.message) {
          message += `: ${eventData.message}`;
        }
        break;
      case 'gift_membership_purchase':
      case 'membershipGiftingEvent':
        message = `gifted ${eventData.giftCount || 1} memberships`;
        if (eventData.memberLevelName) {
          message += ` (${eventData.memberLevelName})`;
        }
        break;
      case 'gift_membership_received':
        // When someone receives a gifted membership
        message = `received a gifted membership`;
        if (eventData.gifter && eventData.gifter !== 'Anonymous Gifter') {
          message += ` from ${eventData.gifter}`;
        }
        if (eventData.memberLevelName) {
          message += ` (${eventData.memberLevelName})`;
        }
        break;
      case 'subscription':
        message = 'subscribed!';
        break;
      case 'jewel_gift':
        message = `üíé ${eventData.giftName} (${eventData.jewelCount} jewels)`;
        break;
      default:
        message = eventData.message || eventData.text || `${eventType}`;
    }

    // Add to chat feed using the properly mapped data
    // Check if message contains HTML emoji tags and use HTML rendering
    const hasEmojis = message.includes('<img') && message.includes('youtube-emoji');
    console.log(`üîç [Chat] Adding YouTube message to chat. HasEmojis: ${hasEmojis}, Message: "${message}"`);
    
    addChat('youtube', eventData.displayName, message, eventData.avatar, null, hasEmojis, extractYouTubeBadges(eventData));
  }

  // TikTok WebSocket
  try {
    const tikWs = new WebSocket('ws://localhost:21213/');
    
    tikWs.onopen = () => {
      console.log('‚ñ∂ TikTok WebSocket connected');
      updateConnectionStatus('tiktok', true);
    };
    
    tikWs.onclose = () => {
      console.log('‚ñ∂ TikTok WebSocket closed');
      updateConnectionStatus('tiktok', false);
    };
    
    tikWs.onerror = (error) => {
      console.error('‚ñ∂ TikTok WebSocket error:', error);
      updateConnectionStatus('tiktok', false);
    };
    
    tikWs.onmessage = e => {
      const m = JSON.parse(e.data);
      console.log('‚ñ∂ TikTok raw event:', m);
      
      if (m.event === 'chat') {
        const d = m.data;
        const avatar = d.profilePictureUrl || icons.tiktok;
        const displayName = d.nickname || d.uniqueId || 'Unknown';
        
        // COMPREHENSIVE LOGGING FOR BADGE INVESTIGATION
        console.log('=== TikTok Chat Message Data Analysis ===');
        console.log('‚ñ∂ TikTok chat FULL DATA STRUCTURE:', JSON.stringify(d, null, 2));
        console.log('‚ñ∂ TikTok chat ALL AVAILABLE KEYS:', Object.keys(d));
        console.log('‚ñ∂ TikTok chat DATA TYPES:', Object.keys(d).map(key => `${key}: ${typeof d[key]}`));
        
        // Look for potential badge fields
        const potentialBadgeFields = [
          'isModerator', 'moderator', 'mod', 'userRole', 'role',
          'isSubscriber', 'subscriber', 'sub', 'followRole', 
          'badges', 'userBadges', 'userLevel', 'level',
          'followInfo', 'subscriptionInfo', 'userInfo', 'authorInfo'
        ];
        
        console.log('‚ñ∂ TikTok POTENTIAL BADGE FIELDS CHECK:');
        potentialBadgeFields.forEach(field => {
          if (d.hasOwnProperty(field)) {
            console.log(`  ‚úÖ FOUND: ${field} =`, d[field]);
          }
        });
        
        // Enhanced logging for TikTok chat messages
        console.log('‚ñ∂ TikTok chat message:', {
          text: d.comment,
          fullData: d,
          hasEmoji: d.comment && (d.comment.includes('\uD83D') || d.comment.includes('\uD83C')), // Basic emoji detection
          charCodes: d.comment ? Array.from(d.comment).map(c => c.charCodeAt(0).toString(16)) : [],
          emotes: d.emotes
        });
        console.log('=== End TikTok Data Analysis ===');
        
        // Process TikTok emotes if present
        let processedMessage = d.comment || '';
        
        // Check if the message has emotes to process
        if (d.emotes && Array.isArray(d.emotes) && d.emotes.length > 0) {
          console.log('‚ñ∂ TikTok message has emotes:', d.emotes);
          
          // Create HTML for each emote
          // Clear the message text since we're just showing emotes
          processedMessage = '';
          
          d.emotes.forEach(emote => {
            if (emote.emoteImageUrl) {
              // Create an image tag for the emote
              const emoteImg = `<img class='emote' src='${emote.emoteImageUrl}' alt='${emote.emoteId || "emote"}' title='${emote.emoteId || ""}'>`;
              // Add the emote to the message
              processedMessage += emoteImg;
            }
          });
          
          // If the message was empty and we only added emotes, add a space for better display
          if (d.comment.trim() === '') {
            console.log('‚ñ∂ TikTok: Empty message with only emotes');
          } else {
            // If there was text in the original message, add it back
            processedMessage = d.comment + ' ' + processedMessage;
          }
          
          // Use innerHTML for messages with emotes
          addChat('tiktok', displayName, processedMessage, avatar, null, true, extractTikTokBadges(d));
        } else {
          // Regular text message without emotes
          addChat('tiktok', displayName, processedMessage, avatar, null, false, extractTikTokBadges(d));
        }
      } else if (m.event === 'gift') {
        const d = m.data;
        // Only show after stacking is complete
        if (d.giftType === 1 && !d.repeatEnd) return;
        const avatar = d.profilePictureUrl || icons.tiktok;
        const displayName = d.nickname || d.uniqueId || 'Unknown';
        const count = d.repeatCount || 1;
        const totalDiamonds = (d.diamondCount || 0) * count;
        const giftIcon = d.giftPictureUrl ? `<img class='gift-icon' src='${d.giftPictureUrl}' alt='gift'>` : '';
        // Format: USERNAME: sent AMOUNT√ó GIFT TITLE GIFT PICTURE (DIAMONDS)
        const giftMsg = `sent ${count}√ó ${d.giftName} ${giftIcon} <span style='font-size:0.85em;color:#FFD700;'>(${totalDiamonds} diamonds)</span>`;
        addChat('tiktok', displayName, giftMsg, avatar);
      } else if (m.event === 'follow') {
        const d = m.data;
        const avatar = d.profilePictureUrl || icons.tiktok;
        const displayName = d.nickname || d.uniqueId || 'Unknown';
        // Format: USERNAME: followed
        const followMsg = `followed`;
        addChat('tiktok', displayName, followMsg, avatar, null, false, extractTikTokBadges(d));
      } else if (m.event === 'subscribe') {
        const d = m.data;
        const avatar = d.profilePictureUrl || icons.tiktok;
        const displayName = d.nickname || d.uniqueId || 'Unknown';
        // Format: USERNAME: subscribed
        const subMsg = `subscribed`;
        addChat('tiktok', displayName, subMsg, avatar, null, false, extractTikTokBadges(d));
      }
    };
  } catch (err) {
    console.error('‚ñ∂ TikTok WebSocket connection failed:', err);
    updateConnectionStatus('tiktok', false);
  }

  // YouTube polling variables
  let ytNextPageToken = '';
  let youtubePollingInterval = null;

  // Set up YouTube service data listeners
  window.electron.ipcRenderer.on('youtube-connection-status', (event, data) => {
    if (data && typeof data.connectionStatus !== 'undefined') {
      updateConnectionStatus('youtube', data.connectionStatus);
    }
  });

  window.electron.ipcRenderer.on('twitch-connection-status', (event, data) => {
    if (data && typeof data.connectionStatus !== 'undefined') {
      updateConnectionStatus('twitch', data.connectionStatus);
    }
  });

  // Twitch Events IPC listener (for all events including subscriptions, bits, raids, follows)
  window.electron.ipcRenderer.on('twitch-data-update', (event, data) => {
    console.log('Received Twitch data update:', data);
    
    // Process all events (subscriptions, raids, follows, etc.)
    // Skip bits events since they're already shown in chat messages
    if (data && data.events && data.events.length > 0) {
      data.events.forEach(event => {
        console.log(`üîç [Chat] Processing Twitch event:`, event);
        // Skip bits/cheer events - they're already displayed in chat messages
        if (event.type === 'bits' || event.type === 'cheer') {
          console.log(`üîç [Chat] Skipping bits event (already shown in chat):`, event);
          return;
        }
        handleTwitchEvent(event.type, event);
      });
    }
    
    // Update connection status
    updateConnectionStatus('twitch', data.connectionStatus);
  });

  // Function to handle Twitch events and display them in chat format
  function handleTwitchEvent(eventType, eventData) {
    console.log(`üîç [Chat] handleTwitchEvent called with type: ${eventType}`, eventData);
    
    // Skip malformed events
    if (!eventType || eventType === 'undefined') {
      console.log(`‚ö†Ô∏è [Chat] Ignoring malformed Twitch event with undefined type`);
      return;
    }
    
    let message = '';
    let displayName = eventData.displayName || eventData.username || 'Unknown';
    let avatar = eventData.avatar || icons.twitch;
    
    switch(eventType) {
      case 'follow':
        message = 'followed';
        break;
      case 'gift_subscription':
        // Handle gift subscriptions from Twitch API service
        displayName = eventData.gifter || eventData.gifterDisplayName || 'Someone';
        avatar = eventData.gifterAvatar || avatar;
        const giftRecipient = eventData.username || eventData.displayName || 'someone';
        message = `gifted a sub to ${giftRecipient}`;
        if (eventData.tier && eventData.tier !== '1000') {
          const tierName = eventData.tier.replace('1000', '1').replace('2000', '2').replace('3000', '3');
          message += ` (Tier ${tierName})`;
        }
        break;
      case 'subscription':
        if (eventData.isGift) {
          // For gift subs, show the gifter as the sender
          displayName = eventData.gifterDisplayName || eventData.gifter || displayName;
          avatar = eventData.gifterAvatar || avatar;
          const recipient = eventData.username || eventData.displayName || 'someone';
          message = `gifted a sub to ${recipient}`;
          if (eventData.tier && eventData.tier !== '1000') {
            const tierName = eventData.tier.replace('1000', '1').replace('2000', '2').replace('3000', '3');
            message += ` (Tier ${tierName})`;
          }
        } else {
          message = 'subscribed';
          if (eventData.tier && eventData.tier !== '1000') {
            const tierName = eventData.tier.replace('1000', '1').replace('2000', '2').replace('3000', '3');
            message += ` (Tier ${tierName})`;
          }
          if (eventData.message) {
            message += `: ${eventData.message}`;
          }
        }
        break;
      // Commented out to prevent duplicate bits/cheer messages
      // Bits are already shown in the regular chat messages via twitch-chat-message
      // case 'bits':
      // case 'cheer':
      //   const bitAmount = eventData.bits || eventData.amount || 0;
      //   message = `cheered ${bitAmount} bits`;
      //   if (eventData.message) {
      //     message += `: ${eventData.message}`;
      //   }
      //   break;
      case 'raid':
        const viewers = eventData.viewers || eventData.viewerCount || 0;
        message = `raided with ${viewers} viewers`;
        break;
      default:
        message = eventData.message || eventData.text || `${eventType}`;
    }

    // Add to chat feed
    addChat('twitch', displayName, message, avatar, null, false, extractTwitchBadges(eventData));
  }

  // Token reload listener for auth refresh
  window.electron.ipcRenderer.on('reload-tokens', async () => {
    console.log('üîÑ [Chat] Reloading tokens from secure storage...');
    TOKENS = await window.electron.ipcRenderer.invoke('get-tokens');
    console.log('‚úÖ [Chat] Tokens reloaded successfully');
  });

  // Handle YouTube emoji cache updates for retroactive replacement
  window.electron.ipcRenderer.on('youtube-emoji-cache-update', (event, newEmojiCount) => {
    console.log(`üé® [Chat] YouTube emoji cache updated with ${newEmojiCount} new emojis - updating recent messages...`);
    updateRecentYouTubeMessagesWithNewEmojis();
  });

  // Initialize YouTube badge URLs cache
  window.youtubeBadgeUrls = {};

  // Function to update YouTube badge URLs from cache
  async function updateYouTubeBadgeUrls() {
    try {
      // Request badge URLs from main process
      const badgeUrls = await window.electron.ipcRenderer.invoke('get-youtube-badge-urls');
      if (badgeUrls) {
        window.youtubeBadgeUrls = badgeUrls;
        console.log('üéñÔ∏è [Chat] YouTube badge URLs updated:', badgeUrls);
      }
    } catch (error) {
      console.error('‚ùå [Chat] Failed to get YouTube badge URLs:', error);
    }
  }

  // Handle YouTube badge cache updates
  window.electron.ipcRenderer.on('youtube-badge-cache-update', (event, newBadgeCount) => {
    console.log(`üéñÔ∏è [Chat] YouTube badge cache updated with ${newBadgeCount} new badges - updating URLs...`);
    updateYouTubeBadgeUrls();
  });

  // Initialize badge URLs on startup
  updateYouTubeBadgeUrls();

  // Handle font size updates
  window.electron.ipcRenderer.on('font-size-update', (event, fontSizes) => {
    if (fontSizes.chatFontSize) {
      document.querySelector('.chat-feed').style.fontSize = fontSizes.chatFontSize + 'px';
      console.log('Chat font size updated to:', fontSizes.chatFontSize + 'px');
    }
    
    // Update username font size
    if (fontSizes.usernameFontSize) {
      // Remove existing style if present
      const existingStyle = document.getElementById('dynamic-username-style');
      if (existingStyle) {
        existingStyle.remove();
      }
      
      // Add new style
      const style = document.createElement('style');
      style.id = 'dynamic-username-style';
      style.textContent = `.username { font-size: ${fontSizes.usernameFontSize}em !important; }`;
      document.head.appendChild(style);
      console.log('Username font size updated to:', fontSizes.usernameFontSize + 'em');
    }
  });

  // Handle text color updates from settings
  window.electron.ipcRenderer.on('text-color-update', (event, textColor) => {
    console.log('Chat text color updated to:', textColor);
    
    // Remove existing dynamic text color style if present
    const existingStyle = document.getElementById('dynamic-text-color-style');
    if (existingStyle) {
      existingStyle.remove();
    }
    
    // Add new text color style
    const style = document.createElement('style');
    style.id = 'dynamic-text-color-style';
    style.textContent = `.message { color: ${textColor} !important; }`;
    document.head.appendChild(style);
  });

  // Handle background color updates from settings
  window.electron.ipcRenderer.on('background-color-update', (event, backgroundColor) => {
    console.log('Chat background color updated to:', backgroundColor);
    
    // Remove existing dynamic background color style if present
    const existingStyle = document.getElementById('dynamic-background-color-style');
    if (existingStyle) {
      existingStyle.remove();
    }
    
    // Add new background color style
    const style = document.createElement('style');
    style.id = 'dynamic-background-color-style';
    style.textContent = `body { background-color: ${backgroundColor} !important; }`;
    document.head.appendChild(style);
  });

  // Handle theme color (events color) updates from settings
  window.electron.ipcRenderer.on('events-color-update', (event, eventsColor) => {
    console.log('Chat username color updated to:', eventsColor);
    
    // Remove existing dynamic username color style if present
    const existingStyle = document.getElementById('dynamic-username-color-style');
    if (existingStyle) {
      existingStyle.remove();
    }
    
    // Add new username color style
    const style = document.createElement('style');
    style.id = 'dynamic-username-color-style';
    style.textContent = `.username { color: ${eventsColor} !important; }`;
    document.head.appendChild(style);
  });

  // Handle TikTok test messages (global function for test system)
  window.handleTikTokMessage = function(messageData) {
    console.log('üß™ [Chat] handleTikTokMessage called with:', messageData);
    
    if (messageData.event === 'chat') {
      const d = messageData.data;
      const avatar = d.profilePictureUrl || icons.tiktok;
      const displayName = d.nickname || d.uniqueId || 'Unknown';
      
      // Process TikTok emotes if present
      let processedMessage = d.comment || '';
      
      // Check if the message has emotes to process
      if (d.emotes && Array.isArray(d.emotes) && d.emotes.length > 0) {
        console.log('‚ñ∂ TikTok test message has emotes:', d.emotes);
        
        // Create HTML for each emote
        processedMessage = '';
        
        d.emotes.forEach(emote => {
          if (emote.emoteImageUrl) {
            const emoteImg = `<img class='emote' src='${emote.emoteImageUrl}' alt='${emote.emoteId || "emote"}' title='${emote.emoteId || ""}'>`;
            processedMessage += emoteImg;
          }
        });
        
        if (d.comment.trim() !== '') {
          processedMessage = d.comment + ' ' + processedMessage;
        }
        
        // Use innerHTML for messages with emotes
        addChat('tiktok', displayName, processedMessage, avatar, null, true, []);
      } else {
        // Regular text message without emotes
        addChat('tiktok', displayName, processedMessage, avatar, null, false, []);
      }
    }
  };

  // Retroactively update recent YouTube messages with newly cached emojis
  async function updateRecentYouTubeMessagesWithNewEmojis() {
    const chatLines = feed.querySelectorAll('.chat-line');
    const recentLines = Array.from(chatLines).slice(-20); // Process last 20 messages
    
    console.log(`üé® [Chat] Checking ${recentLines.length} recent messages for YouTube emoji updates...`);
    
    for (const line of recentLines) {
      const messageDiv = line.querySelector('.message');
      const platformIcon = line.querySelector('.platform-icon');
      
      // Only process YouTube messages that contain emoji shortcodes
      if (messageDiv && platformIcon && platformIcon.alt === 'youtube') {
        const currentText = messageDiv.textContent;
        
        // Check if message contains emoji shortcodes that might now be cached
        if (currentText && currentText.includes(':')) {
          console.log(`üé® [Chat] Re-processing YouTube message: "${currentText}"`);
          
          try {
            // Request fresh processing from YouTube API service
            const processedMessage = await window.electron.ipcRenderer.invoke('youtube-process-message', currentText);
            
            if (processedMessage && processedMessage !== currentText) {
              console.log(`üé® [Chat] ‚úÖ Updated message: "${currentText}" -> "${processedMessage}"`);
              messageDiv.innerHTML = processedMessage;
            }
          } catch (error) {
            console.error('üé® [Chat] ‚ùå Failed to re-process message:', error);
          }
        }
      }
    }
  }
})();
  </script>
</body>
</html>
